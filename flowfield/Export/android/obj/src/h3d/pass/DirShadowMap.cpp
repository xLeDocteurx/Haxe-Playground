#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_h2d_col_IBounds
#include <h2d/col/IBounds.h>
#endif
#ifndef INCLUDED_h3d_Camera
#include <h3d/Camera.h>
#endif
#ifndef INCLUDED_h3d_Engine
#include <h3d/Engine.h>
#endif
#ifndef INCLUDED_h3d_IDrawable
#include <h3d/IDrawable.h>
#endif
#ifndef INCLUDED_h3d_Matrix
#include <h3d/Matrix.h>
#endif
#ifndef INCLUDED_h3d_Vector
#include <h3d/Vector.h>
#endif
#ifndef INCLUDED_h3d_col_Bounds
#include <h3d/col/Bounds.h>
#endif
#ifndef INCLUDED_h3d_col_Collider
#include <h3d/col/Collider.h>
#endif
#ifndef INCLUDED_h3d_col_Frustum
#include <h3d/col/Frustum.h>
#endif
#ifndef INCLUDED_h3d_impl_Driver
#include <h3d/impl/Driver.h>
#endif
#ifndef INCLUDED_h3d_impl_Feature
#include <h3d/impl/Feature.h>
#endif
#ifndef INCLUDED_h3d_impl_RenderContext
#include <h3d/impl/RenderContext.h>
#endif
#ifndef INCLUDED_h3d_impl_TextureCache
#include <h3d/impl/TextureCache.h>
#endif
#ifndef INCLUDED_h3d_mat_BaseMaterial
#include <h3d/mat/BaseMaterial.h>
#endif
#ifndef INCLUDED_h3d_mat_DepthBuffer
#include <h3d/mat/DepthBuffer.h>
#endif
#ifndef INCLUDED_h3d_mat_DepthFormat
#include <h3d/mat/DepthFormat.h>
#endif
#ifndef INCLUDED_h3d_mat_Material
#include <h3d/mat/Material.h>
#endif
#ifndef INCLUDED_h3d_mat_Texture
#include <h3d/mat/Texture.h>
#endif
#ifndef INCLUDED_h3d_mat_TextureFlags
#include <h3d/mat/TextureFlags.h>
#endif
#ifndef INCLUDED_h3d_pass_Base
#include <h3d/pass/Base.h>
#endif
#ifndef INCLUDED_h3d_pass_Blur
#include <h3d/pass/Blur.h>
#endif
#ifndef INCLUDED_h3d_pass_Border
#include <h3d/pass/Border.h>
#endif
#ifndef INCLUDED_h3d_pass_Default
#include <h3d/pass/Default.h>
#endif
#ifndef INCLUDED_h3d_pass_DirShadowMap
#include <h3d/pass/DirShadowMap.h>
#endif
#ifndef INCLUDED_h3d_pass_PassList
#include <h3d/pass/PassList.h>
#endif
#ifndef INCLUDED_h3d_pass_PassObject
#include <h3d/pass/PassObject.h>
#endif
#ifndef INCLUDED_h3d_pass_RenderMode
#include <h3d/pass/RenderMode.h>
#endif
#ifndef INCLUDED_h3d_pass_ScreenFx
#include <h3d/pass/ScreenFx.h>
#endif
#ifndef INCLUDED_h3d_pass_ShaderManager
#include <h3d/pass/ShaderManager.h>
#endif
#ifndef INCLUDED_h3d_pass_ShadowSamplingKind
#include <h3d/pass/ShadowSamplingKind.h>
#endif
#ifndef INCLUDED_h3d_pass_Shadows
#include <h3d/pass/Shadows.h>
#endif
#ifndef INCLUDED_h3d_prim_Primitive
#include <h3d/prim/Primitive.h>
#endif
#ifndef INCLUDED_h3d_scene_Light
#include <h3d/scene/Light.h>
#endif
#ifndef INCLUDED_h3d_scene_LightSystem
#include <h3d/scene/LightSystem.h>
#endif
#ifndef INCLUDED_h3d_scene_Mesh
#include <h3d/scene/Mesh.h>
#endif
#ifndef INCLUDED_h3d_scene_Object
#include <h3d/scene/Object.h>
#endif
#ifndef INCLUDED_h3d_scene_RenderContext
#include <h3d/scene/RenderContext.h>
#endif
#ifndef INCLUDED_h3d_scene_Scene
#include <h3d/scene/Scene.h>
#endif
#ifndef INCLUDED_h3d_shader_DirShadow
#include <h3d/shader/DirShadow.h>
#endif
#ifndef INCLUDED_h3d_shader_MinMaxShader
#include <h3d/shader/MinMaxShader.h>
#endif
#ifndef INCLUDED_h3d_shader_ScreenShader
#include <h3d/shader/ScreenShader.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_BytesBuffer
#include <haxe/io/BytesBuffer.h>
#endif
#ifndef INCLUDED_haxe_io_BytesInput
#include <haxe/io/BytesInput.h>
#endif
#ifndef INCLUDED_haxe_io_FPHelper
#include <haxe/io/FPHelper.h>
#endif
#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_haxe_zip_Compress
#include <haxe/zip/Compress.h>
#endif
#ifndef INCLUDED_haxe_zip_Uncompress
#include <haxe/zip/Uncompress.h>
#endif
#ifndef INCLUDED_hxd_InteractiveScene
#include <hxd/InteractiveScene.h>
#endif
#ifndef INCLUDED_hxd_PixelFormat
#include <hxd/PixelFormat.h>
#endif
#ifndef INCLUDED_hxd_Pixels
#include <hxd/Pixels.h>
#endif
#ifndef INCLUDED_hxd_impl_AnyProps
#include <hxd/impl/AnyProps.h>
#endif
#ifndef INCLUDED_hxd_impl__Serializable_NoSerializeSupport
#include <hxd/impl/_Serializable/NoSerializeSupport.h>
#endif
#ifndef INCLUDED_hxsl_Channel
#include <hxsl/Channel.h>
#endif
#ifndef INCLUDED_hxsl_Globals
#include <hxsl/Globals.h>
#endif
#ifndef INCLUDED_hxsl_Output
#include <hxsl/Output.h>
#endif
#ifndef INCLUDED_hxsl_Shader
#include <hxsl/Shader.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b538f9489ffcca0c_3_new,"h3d.pass.DirShadowMap","new",0xd8b3eb69,"h3d.pass.DirShadowMap.new","h3d/pass/DirShadowMap.hx",3,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_28_set_mode,"h3d.pass.DirShadowMap","set_mode",0x7e0d2cb7,"h3d.pass.DirShadowMap.set_mode","h3d/pass/DirShadowMap.hx",28,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_33_set_enabled,"h3d.pass.DirShadowMap","set_enabled",0x278837ad,"h3d.pass.DirShadowMap.set_enabled","h3d/pass/DirShadowMap.hx",33,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_38_set_size,"h3d.pass.DirShadowMap","set_size",0x81fffa15,"h3d.pass.DirShadowMap.set_size","h3d/pass/DirShadowMap.hx",38,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_46_dispose,"h3d.pass.DirShadowMap","dispose",0x43f15428,"h3d.pass.DirShadowMap.dispose","h3d/pass/DirShadowMap.hx",46,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_53_getShadowTex,"h3d.pass.DirShadowMap","getShadowTex",0xbcded248,"h3d.pass.DirShadowMap.getShadowTex","h3d/pass/DirShadowMap.hx",53,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_56___default_calcShadowBounds,"h3d.pass.DirShadowMap","__default_calcShadowBounds",0x262e605f,"h3d.pass.DirShadowMap.__default_calcShadowBounds","h3d/pass/DirShadowMap.hx",56,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_62___default_calcShadowBounds,"h3d.pass.DirShadowMap","__default_calcShadowBounds",0x262e605f,"h3d.pass.DirShadowMap.__default_calcShadowBounds","h3d/pass/DirShadowMap.hx",62,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_137_setGlobals,"h3d.pass.DirShadowMap","setGlobals",0xaf877245,"h3d.pass.DirShadowMap.setGlobals","h3d/pass/DirShadowMap.hx",137,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_147_syncShader,"h3d.pass.DirShadowMap","syncShader",0x582cebf7,"h3d.pass.DirShadowMap.syncShader","h3d/pass/DirShadowMap.hx",147,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_165_saveStaticData,"h3d.pass.DirShadowMap","saveStaticData",0x6673cb2c,"h3d.pass.DirShadowMap.saveStaticData","h3d/pass/DirShadowMap.hx",165,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_190_loadStaticData,"h3d.pass.DirShadowMap","loadStaticData",0xfeaaf755,"h3d.pass.DirShadowMap.loadStaticData","h3d/pass/DirShadowMap.hx",190,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_221_draw,"h3d.pass.DirShadowMap","draw",0xbe27b8db,"h3d.pass.DirShadowMap.draw","h3d/pass/DirShadowMap.hx",221,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_228_draw,"h3d.pass.DirShadowMap","draw",0xbe27b8db,"h3d.pass.DirShadowMap.draw","h3d/pass/DirShadowMap.hx",228,0x2699c3c7)
HX_LOCAL_STACK_FRAME(_hx_pos_b538f9489ffcca0c_279_computeStatic,"h3d.pass.DirShadowMap","computeStatic",0x7df3abce,"h3d.pass.DirShadowMap.computeStatic","h3d/pass/DirShadowMap.hx",279,0x2699c3c7)
namespace h3d{
namespace pass{

void DirShadowMap_obj::__construct( ::h3d::scene::Light light){
            	HX_GC_STACKFRAME(&_hx_pos_b538f9489ffcca0c_3_new)
HXLINE(  16)		this->minDist = ((Float)-1.0);
HXLINE(  14)		this->maxDist = ((Float)-1.0);
HXLINE(  12)		this->autoShrink = true;
HXLINE(   9)		this->mergePass =  ::h3d::pass::ScreenFx_obj::__alloc( HX_CTX , ::h3d::shader::MinMaxShader_obj::__alloc( HX_CTX ),null());
HXLINE(  19)		super::__construct(light);
HXLINE(  20)		this->lightCamera =  ::h3d::Camera_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE(  21)		this->lightCamera->orthoBounds =  ::h3d::col::Bounds_obj::__alloc( HX_CTX );
HXLINE(  22)		this->shader = (this->dshader =  ::h3d::shader::DirShadow_obj::__alloc( HX_CTX ));
HXLINE(  23)		this->border =  ::h3d::pass::Border_obj::__alloc( HX_CTX ,this->size,this->size,null());
HXLINE(  24)		this->customDepth = ::h3d::Engine_obj::CURRENT->driver->hasFeature(::h3d::impl::Feature_obj::AllocDepthBuffer_dyn());
HXLINE(  25)		if (!(this->customDepth)) {
HXLINE(  25)			this->depth = ::h3d::mat::DepthBuffer_obj::getDefault();
            		}
            	}

Dynamic DirShadowMap_obj::__CreateEmpty() { return new DirShadowMap_obj; }

void *DirShadowMap_obj::_hx_vtable = 0;

Dynamic DirShadowMap_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< DirShadowMap_obj > _hx_result = new DirShadowMap_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool DirShadowMap_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2eacfc8f) {
		if (inClassId<=(int)0x04b798b9) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x04b798b9;
		} else {
			return inClassId==(int)0x2eacfc8f;
		}
	} else {
		return inClassId==(int)0x32234ba9 || inClassId==(int)0x6e5907d7;
	}
}

 ::h3d::pass::RenderMode DirShadowMap_obj::set_mode( ::h3d::pass::RenderMode m){
            	HX_STACKFRAME(&_hx_pos_b538f9489ffcca0c_28_set_mode)
HXLINE(  29)		{
HXLINE(  29)			 ::h3d::shader::DirShadow _this = this->dshader;
HXDLIN(  29)			_this->constModified = true;
HXDLIN(  29)			_this->enable__ = ::hx::IsPointerNotEq( m,::h3d::pass::RenderMode_obj::None_dyn() );
            		}
HXLINE(  30)		return (this->mode = m);
            	}


bool DirShadowMap_obj::set_enabled(bool b){
            	HX_STACKFRAME(&_hx_pos_b538f9489ffcca0c_33_set_enabled)
HXLINE(  34)		{
HXLINE(  34)			 ::h3d::shader::DirShadow _this = this->dshader;
HXDLIN(  34)			bool _v;
HXDLIN(  34)			if (b) {
HXLINE(  34)				_v = ::hx::IsPointerNotEq( this->mode,::h3d::pass::RenderMode_obj::None_dyn() );
            			}
            			else {
HXLINE(  34)				_v = false;
            			}
HXDLIN(  34)			_this->constModified = true;
HXDLIN(  34)			_this->enable__ = _v;
            		}
HXLINE(  35)		return (this->enabled = b);
            	}


int DirShadowMap_obj::set_size(int s){
            	HX_GC_STACKFRAME(&_hx_pos_b538f9489ffcca0c_38_set_size)
HXLINE(  39)		bool _hx_tmp;
HXDLIN(  39)		if (::hx::IsNotNull( this->border )) {
HXLINE(  39)			_hx_tmp = (this->size != s);
            		}
            		else {
HXLINE(  39)			_hx_tmp = false;
            		}
HXDLIN(  39)		if (_hx_tmp) {
HXLINE(  40)			this->border->dispose();
HXLINE(  41)			this->border =  ::h3d::pass::Border_obj::__alloc( HX_CTX ,s,s,null());
            		}
HXLINE(  43)		return this->super::set_size(s);
            	}


void DirShadowMap_obj::dispose(){
            	HX_STACKFRAME(&_hx_pos_b538f9489ffcca0c_46_dispose)
HXLINE(  47)		this->super::dispose();
HXLINE(  48)		bool _hx_tmp;
HXDLIN(  48)		if (this->customDepth) {
HXLINE(  48)			_hx_tmp = ::hx::IsNotNull( this->depth );
            		}
            		else {
HXLINE(  48)			_hx_tmp = false;
            		}
HXDLIN(  48)		if (_hx_tmp) {
HXLINE(  48)			this->depth->dispose();
            		}
HXLINE(  49)		this->border->dispose();
            	}


 ::h3d::mat::Texture DirShadowMap_obj::getShadowTex(){
            	HX_STACKFRAME(&_hx_pos_b538f9489ffcca0c_53_getShadowTex)
HXDLIN(  53)		return this->dshader->shadowMap__;
            	}


HX_BEGIN_DEFAULT_FUNC(__default_calcShadowBounds,DirShadowMap_obj)
void _hx_run( ::h3d::Camera camera){
            	HX_GC_STACKFRAME(&_hx_pos_b538f9489ffcca0c_56___default_calcShadowBounds)
HXLINE(  57)		 ::h3d::col::Bounds bounds = camera->orthoBounds;
HXLINE(  59)		if (( ( ::h3d::pass::DirShadowMap)(__this) )->autoShrink) {
            			HX_BEGIN_LOCAL_FUNC_S3(::hx::LocalFunc,_hx_Closure_0, ::h3d::col::Bounds,bounds, ::h3d::Camera,camera, ::h3d::Matrix,mtmp) HXARGC(1)
            			void _hx_run( ::h3d::scene::Mesh m){
            				HX_GC_STACKFRAME(&_hx_pos_b538f9489ffcca0c_62___default_calcShadowBounds)
HXLINE(  63)				bool _hx_tmp;
HXDLIN(  63)				if (::hx::IsNotNull( m->primitive )) {
HXLINE(  63)					_hx_tmp = !(m->material->castShadows);
            				}
            				else {
HXLINE(  63)					_hx_tmp = true;
            				}
HXDLIN(  63)				if (_hx_tmp) {
HXLINE(  63)					return;
            				}
HXLINE(  64)				 ::h3d::col::Bounds b = m->primitive->getBounds();
HXLINE(  65)				if ((b->xMin > b->xMax)) {
HXLINE(  65)					return;
            				}
HXLINE(  66)				 ::h3d::Matrix mtmp1 = mtmp;
HXDLIN(  66)				 ::h3d::Matrix _hx_tmp1 = m->getAbsPos();
HXDLIN(  66)				mtmp1->multiply3x4(_hx_tmp1,camera->mcam);
HXLINE(  68)				Float p_x = b->xMin;
HXDLIN(  68)				Float p_y = b->yMin;
HXDLIN(  68)				Float p_z = b->zMin;
HXLINE(  69)				{
HXLINE(  69)					Float px = ((((p_x * mtmp->_11) + (p_y * mtmp->_21)) + (p_z * mtmp->_31)) + mtmp->_41);
HXDLIN(  69)					Float py = ((((p_x * mtmp->_12) + (p_y * mtmp->_22)) + (p_z * mtmp->_32)) + mtmp->_42);
HXDLIN(  69)					Float pz = ((((p_x * mtmp->_13) + (p_y * mtmp->_23)) + (p_z * mtmp->_33)) + mtmp->_43);
HXDLIN(  69)					p_x = px;
HXDLIN(  69)					p_y = py;
HXDLIN(  69)					p_z = pz;
            				}
HXLINE(  70)				{
HXLINE(  70)					if ((p_x < bounds->xMin)) {
HXLINE(  70)						bounds->xMin = p_x;
            					}
HXDLIN(  70)					if ((p_x > bounds->xMax)) {
HXLINE(  70)						bounds->xMax = p_x;
            					}
HXDLIN(  70)					if ((p_y < bounds->yMin)) {
HXLINE(  70)						bounds->yMin = p_y;
            					}
HXDLIN(  70)					if ((p_y > bounds->yMax)) {
HXLINE(  70)						bounds->yMax = p_y;
            					}
HXDLIN(  70)					if ((p_z < bounds->zMin)) {
HXLINE(  70)						bounds->zMin = p_z;
            					}
HXDLIN(  70)					if ((p_z > bounds->zMax)) {
HXLINE(  70)						bounds->zMax = p_z;
            					}
            				}
HXLINE(  72)				Float p_x1 = b->xMin;
HXDLIN(  72)				Float p_y1 = b->yMin;
HXDLIN(  72)				Float p_z1 = b->zMax;
HXLINE(  73)				{
HXLINE(  73)					Float px1 = ((((p_x1 * mtmp->_11) + (p_y1 * mtmp->_21)) + (p_z1 * mtmp->_31)) + mtmp->_41);
HXDLIN(  73)					Float py1 = ((((p_x1 * mtmp->_12) + (p_y1 * mtmp->_22)) + (p_z1 * mtmp->_32)) + mtmp->_42);
HXDLIN(  73)					Float pz1 = ((((p_x1 * mtmp->_13) + (p_y1 * mtmp->_23)) + (p_z1 * mtmp->_33)) + mtmp->_43);
HXDLIN(  73)					p_x1 = px1;
HXDLIN(  73)					p_y1 = py1;
HXDLIN(  73)					p_z1 = pz1;
            				}
HXLINE(  74)				{
HXLINE(  74)					if ((p_x1 < bounds->xMin)) {
HXLINE(  74)						bounds->xMin = p_x1;
            					}
HXDLIN(  74)					if ((p_x1 > bounds->xMax)) {
HXLINE(  74)						bounds->xMax = p_x1;
            					}
HXDLIN(  74)					if ((p_y1 < bounds->yMin)) {
HXLINE(  74)						bounds->yMin = p_y1;
            					}
HXDLIN(  74)					if ((p_y1 > bounds->yMax)) {
HXLINE(  74)						bounds->yMax = p_y1;
            					}
HXDLIN(  74)					if ((p_z1 < bounds->zMin)) {
HXLINE(  74)						bounds->zMin = p_z1;
            					}
HXDLIN(  74)					if ((p_z1 > bounds->zMax)) {
HXLINE(  74)						bounds->zMax = p_z1;
            					}
            				}
HXLINE(  76)				Float p_x2 = b->xMin;
HXDLIN(  76)				Float p_y2 = b->yMax;
HXDLIN(  76)				Float p_z2 = b->zMin;
HXLINE(  77)				{
HXLINE(  77)					Float px2 = ((((p_x2 * mtmp->_11) + (p_y2 * mtmp->_21)) + (p_z2 * mtmp->_31)) + mtmp->_41);
HXDLIN(  77)					Float py2 = ((((p_x2 * mtmp->_12) + (p_y2 * mtmp->_22)) + (p_z2 * mtmp->_32)) + mtmp->_42);
HXDLIN(  77)					Float pz2 = ((((p_x2 * mtmp->_13) + (p_y2 * mtmp->_23)) + (p_z2 * mtmp->_33)) + mtmp->_43);
HXDLIN(  77)					p_x2 = px2;
HXDLIN(  77)					p_y2 = py2;
HXDLIN(  77)					p_z2 = pz2;
            				}
HXLINE(  78)				{
HXLINE(  78)					if ((p_x2 < bounds->xMin)) {
HXLINE(  78)						bounds->xMin = p_x2;
            					}
HXDLIN(  78)					if ((p_x2 > bounds->xMax)) {
HXLINE(  78)						bounds->xMax = p_x2;
            					}
HXDLIN(  78)					if ((p_y2 < bounds->yMin)) {
HXLINE(  78)						bounds->yMin = p_y2;
            					}
HXDLIN(  78)					if ((p_y2 > bounds->yMax)) {
HXLINE(  78)						bounds->yMax = p_y2;
            					}
HXDLIN(  78)					if ((p_z2 < bounds->zMin)) {
HXLINE(  78)						bounds->zMin = p_z2;
            					}
HXDLIN(  78)					if ((p_z2 > bounds->zMax)) {
HXLINE(  78)						bounds->zMax = p_z2;
            					}
            				}
HXLINE(  80)				Float p_x3 = b->xMin;
HXDLIN(  80)				Float p_y3 = b->yMax;
HXDLIN(  80)				Float p_z3 = b->zMax;
HXLINE(  81)				{
HXLINE(  81)					Float px3 = ((((p_x3 * mtmp->_11) + (p_y3 * mtmp->_21)) + (p_z3 * mtmp->_31)) + mtmp->_41);
HXDLIN(  81)					Float py3 = ((((p_x3 * mtmp->_12) + (p_y3 * mtmp->_22)) + (p_z3 * mtmp->_32)) + mtmp->_42);
HXDLIN(  81)					Float pz3 = ((((p_x3 * mtmp->_13) + (p_y3 * mtmp->_23)) + (p_z3 * mtmp->_33)) + mtmp->_43);
HXDLIN(  81)					p_x3 = px3;
HXDLIN(  81)					p_y3 = py3;
HXDLIN(  81)					p_z3 = pz3;
            				}
HXLINE(  82)				{
HXLINE(  82)					if ((p_x3 < bounds->xMin)) {
HXLINE(  82)						bounds->xMin = p_x3;
            					}
HXDLIN(  82)					if ((p_x3 > bounds->xMax)) {
HXLINE(  82)						bounds->xMax = p_x3;
            					}
HXDLIN(  82)					if ((p_y3 < bounds->yMin)) {
HXLINE(  82)						bounds->yMin = p_y3;
            					}
HXDLIN(  82)					if ((p_y3 > bounds->yMax)) {
HXLINE(  82)						bounds->yMax = p_y3;
            					}
HXDLIN(  82)					if ((p_z3 < bounds->zMin)) {
HXLINE(  82)						bounds->zMin = p_z3;
            					}
HXDLIN(  82)					if ((p_z3 > bounds->zMax)) {
HXLINE(  82)						bounds->zMax = p_z3;
            					}
            				}
HXLINE(  84)				Float p_x4 = b->xMax;
HXDLIN(  84)				Float p_y4 = b->yMin;
HXDLIN(  84)				Float p_z4 = b->zMin;
HXLINE(  85)				{
HXLINE(  85)					Float px4 = ((((p_x4 * mtmp->_11) + (p_y4 * mtmp->_21)) + (p_z4 * mtmp->_31)) + mtmp->_41);
HXDLIN(  85)					Float py4 = ((((p_x4 * mtmp->_12) + (p_y4 * mtmp->_22)) + (p_z4 * mtmp->_32)) + mtmp->_42);
HXDLIN(  85)					Float pz4 = ((((p_x4 * mtmp->_13) + (p_y4 * mtmp->_23)) + (p_z4 * mtmp->_33)) + mtmp->_43);
HXDLIN(  85)					p_x4 = px4;
HXDLIN(  85)					p_y4 = py4;
HXDLIN(  85)					p_z4 = pz4;
            				}
HXLINE(  86)				{
HXLINE(  86)					if ((p_x4 < bounds->xMin)) {
HXLINE(  86)						bounds->xMin = p_x4;
            					}
HXDLIN(  86)					if ((p_x4 > bounds->xMax)) {
HXLINE(  86)						bounds->xMax = p_x4;
            					}
HXDLIN(  86)					if ((p_y4 < bounds->yMin)) {
HXLINE(  86)						bounds->yMin = p_y4;
            					}
HXDLIN(  86)					if ((p_y4 > bounds->yMax)) {
HXLINE(  86)						bounds->yMax = p_y4;
            					}
HXDLIN(  86)					if ((p_z4 < bounds->zMin)) {
HXLINE(  86)						bounds->zMin = p_z4;
            					}
HXDLIN(  86)					if ((p_z4 > bounds->zMax)) {
HXLINE(  86)						bounds->zMax = p_z4;
            					}
            				}
HXLINE(  88)				Float p_x5 = b->xMax;
HXDLIN(  88)				Float p_y5 = b->yMin;
HXDLIN(  88)				Float p_z5 = b->zMax;
HXLINE(  89)				{
HXLINE(  89)					Float px5 = ((((p_x5 * mtmp->_11) + (p_y5 * mtmp->_21)) + (p_z5 * mtmp->_31)) + mtmp->_41);
HXDLIN(  89)					Float py5 = ((((p_x5 * mtmp->_12) + (p_y5 * mtmp->_22)) + (p_z5 * mtmp->_32)) + mtmp->_42);
HXDLIN(  89)					Float pz5 = ((((p_x5 * mtmp->_13) + (p_y5 * mtmp->_23)) + (p_z5 * mtmp->_33)) + mtmp->_43);
HXDLIN(  89)					p_x5 = px5;
HXDLIN(  89)					p_y5 = py5;
HXDLIN(  89)					p_z5 = pz5;
            				}
HXLINE(  90)				{
HXLINE(  90)					if ((p_x5 < bounds->xMin)) {
HXLINE(  90)						bounds->xMin = p_x5;
            					}
HXDLIN(  90)					if ((p_x5 > bounds->xMax)) {
HXLINE(  90)						bounds->xMax = p_x5;
            					}
HXDLIN(  90)					if ((p_y5 < bounds->yMin)) {
HXLINE(  90)						bounds->yMin = p_y5;
            					}
HXDLIN(  90)					if ((p_y5 > bounds->yMax)) {
HXLINE(  90)						bounds->yMax = p_y5;
            					}
HXDLIN(  90)					if ((p_z5 < bounds->zMin)) {
HXLINE(  90)						bounds->zMin = p_z5;
            					}
HXDLIN(  90)					if ((p_z5 > bounds->zMax)) {
HXLINE(  90)						bounds->zMax = p_z5;
            					}
            				}
HXLINE(  92)				Float p_x6 = b->xMax;
HXDLIN(  92)				Float p_y6 = b->yMax;
HXDLIN(  92)				Float p_z6 = b->zMin;
HXLINE(  93)				{
HXLINE(  93)					Float px6 = ((((p_x6 * mtmp->_11) + (p_y6 * mtmp->_21)) + (p_z6 * mtmp->_31)) + mtmp->_41);
HXDLIN(  93)					Float py6 = ((((p_x6 * mtmp->_12) + (p_y6 * mtmp->_22)) + (p_z6 * mtmp->_32)) + mtmp->_42);
HXDLIN(  93)					Float pz6 = ((((p_x6 * mtmp->_13) + (p_y6 * mtmp->_23)) + (p_z6 * mtmp->_33)) + mtmp->_43);
HXDLIN(  93)					p_x6 = px6;
HXDLIN(  93)					p_y6 = py6;
HXDLIN(  93)					p_z6 = pz6;
            				}
HXLINE(  94)				{
HXLINE(  94)					if ((p_x6 < bounds->xMin)) {
HXLINE(  94)						bounds->xMin = p_x6;
            					}
HXDLIN(  94)					if ((p_x6 > bounds->xMax)) {
HXLINE(  94)						bounds->xMax = p_x6;
            					}
HXDLIN(  94)					if ((p_y6 < bounds->yMin)) {
HXLINE(  94)						bounds->yMin = p_y6;
            					}
HXDLIN(  94)					if ((p_y6 > bounds->yMax)) {
HXLINE(  94)						bounds->yMax = p_y6;
            					}
HXDLIN(  94)					if ((p_z6 < bounds->zMin)) {
HXLINE(  94)						bounds->zMin = p_z6;
            					}
HXDLIN(  94)					if ((p_z6 > bounds->zMax)) {
HXLINE(  94)						bounds->zMax = p_z6;
            					}
            				}
HXLINE(  96)				Float p_x7 = b->xMax;
HXDLIN(  96)				Float p_y7 = b->yMax;
HXDLIN(  96)				Float p_z7 = b->zMax;
HXLINE(  97)				{
HXLINE(  97)					Float px7 = ((((p_x7 * mtmp->_11) + (p_y7 * mtmp->_21)) + (p_z7 * mtmp->_31)) + mtmp->_41);
HXDLIN(  97)					Float py7 = ((((p_x7 * mtmp->_12) + (p_y7 * mtmp->_22)) + (p_z7 * mtmp->_32)) + mtmp->_42);
HXDLIN(  97)					Float pz7 = ((((p_x7 * mtmp->_13) + (p_y7 * mtmp->_23)) + (p_z7 * mtmp->_33)) + mtmp->_43);
HXDLIN(  97)					p_x7 = px7;
HXDLIN(  97)					p_y7 = py7;
HXDLIN(  97)					p_z7 = pz7;
            				}
HXLINE(  98)				{
HXLINE(  98)					if ((p_x7 < bounds->xMin)) {
HXLINE(  98)						bounds->xMin = p_x7;
            					}
HXDLIN(  98)					if ((p_x7 > bounds->xMax)) {
HXLINE(  98)						bounds->xMax = p_x7;
            					}
HXDLIN(  98)					if ((p_y7 < bounds->yMin)) {
HXLINE(  98)						bounds->yMin = p_y7;
            					}
HXDLIN(  98)					if ((p_y7 > bounds->yMax)) {
HXLINE(  98)						bounds->yMax = p_y7;
            					}
HXDLIN(  98)					if ((p_z7 < bounds->zMin)) {
HXLINE(  98)						bounds->zMin = p_z7;
            					}
HXDLIN(  98)					if ((p_z7 > bounds->zMax)) {
HXLINE(  98)						bounds->zMax = p_z7;
            					}
            				}
            			}
            			HX_END_LOCAL_FUNC1((void))

HXLINE(  61)			 ::h3d::Matrix mtmp =  ::h3d::Matrix_obj::__alloc( HX_CTX );
HXLINE(  62)			( ( ::h3d::pass::Base)(__this) )->ctx->scene->iterVisibleMeshes( ::Dynamic(new _hx_Closure_0(bounds,camera,mtmp)));
            		}
            		else {
HXLINE( 103)			if (::hx::IsPointerEq( ( ( ::h3d::pass::Shadows)(__this) )->mode,::h3d::pass::RenderMode_obj::Dynamic_dyn() )) {
HXLINE( 104)				bounds->xMin = ((Float)-1e20);
HXDLIN( 104)				bounds->xMax = ((Float)1e20);
HXDLIN( 104)				bounds->yMin = ((Float)-1e20);
HXDLIN( 104)				bounds->yMax = ((Float)1e20);
HXDLIN( 104)				bounds->zMin = ((Float)-1e20);
HXDLIN( 104)				bounds->zMax = ((Float)1e20);
            			}
            		}
HXLINE( 107)		if (::hx::IsPointerEq( ( ( ::h3d::pass::Shadows)(__this) )->mode,::h3d::pass::RenderMode_obj::Dynamic_dyn() )) {
HXLINE( 110)			 ::h3d::col::Bounds cameraBounds =  ::h3d::col::Bounds_obj::__alloc( HX_CTX );
HXLINE( 111)			Float zMax = ((Float)1.0);
HXLINE( 112)			Float zMin = ((Float)0.0);
HXLINE( 113)			Float n = ( ( ::h3d::pass::Base)(__this) )->ctx->camera->zNear;
HXLINE( 114)			Float f = ( ( ::h3d::pass::Base)(__this) )->ctx->camera->zFar;
HXLINE( 115)			if ((( ( ::h3d::pass::DirShadowMap)(__this) )->maxDist > 0)) {
HXLINE( 116)				Float f1 = ( ( ::h3d::pass::DirShadowMap)(__this) )->maxDist;
HXDLIN( 116)				Float zMax1;
HXDLIN( 116)				if ((f1 < n)) {
HXLINE( 116)					zMax1 = n;
            				}
            				else {
HXLINE( 116)					if ((f1 > f)) {
HXLINE( 116)						zMax1 = f;
            					}
            					else {
HXLINE( 116)						zMax1 = f1;
            					}
            				}
HXDLIN( 116)				zMax = (((((f + n) - (((((Float)2.0) * n) * f) / zMax1)) / (f - n)) + ((Float)1.0)) / ((Float)2.0));
            			}
HXLINE( 117)			if ((( ( ::h3d::pass::DirShadowMap)(__this) )->minDist > 0)) {
HXLINE( 118)				Float f1 = ( ( ::h3d::pass::DirShadowMap)(__this) )->minDist;
HXDLIN( 118)				Float zMin1;
HXDLIN( 118)				if ((f1 < n)) {
HXLINE( 118)					zMin1 = n;
            				}
            				else {
HXLINE( 118)					if ((f1 > f)) {
HXLINE( 118)						zMin1 = f;
            					}
            					else {
HXLINE( 118)						zMin1 = f1;
            					}
            				}
HXDLIN( 118)				zMin = (((((f + n) - (((((Float)2.0) * n) * f) / zMin1)) / (f - n)) + ((Float)1.0)) / ((Float)2.0));
            			}
HXLINE( 119)			{
HXLINE( 119)				int _g = 0;
HXDLIN( 119)				::Array< ::Dynamic> _g1 = ( ( ::h3d::pass::Base)(__this) )->ctx->camera->getFrustumCorners(zMax,zMin);
HXDLIN( 119)				while((_g < _g1->length)){
HXLINE( 119)					 ::h3d::Vector pt = _g1->__get(_g).StaticCast<  ::h3d::Vector >();
HXDLIN( 119)					_g = (_g + 1);
HXLINE( 120)					{
HXLINE( 120)						 ::h3d::Matrix m = camera->mcam;
HXDLIN( 120)						Float px = ((((pt->x * m->_11) + (pt->y * m->_21)) + (pt->z * m->_31)) + (pt->w * m->_41));
HXDLIN( 120)						Float py = ((((pt->x * m->_12) + (pt->y * m->_22)) + (pt->z * m->_32)) + (pt->w * m->_42));
HXDLIN( 120)						Float pz = ((((pt->x * m->_13) + (pt->y * m->_23)) + (pt->z * m->_33)) + (pt->w * m->_43));
HXDLIN( 120)						Float pw = ((((pt->x * m->_14) + (pt->y * m->_24)) + (pt->z * m->_34)) + (pt->w * m->_44));
HXDLIN( 120)						pt->x = px;
HXDLIN( 120)						pt->y = py;
HXDLIN( 120)						pt->z = pz;
HXDLIN( 120)						pt->w = pw;
            					}
HXLINE( 121)					{
HXLINE( 121)						Float x = pt->x;
HXDLIN( 121)						Float y = pt->y;
HXDLIN( 121)						Float z = pt->z;
HXDLIN( 121)						if ((x < cameraBounds->xMin)) {
HXLINE( 121)							cameraBounds->xMin = x;
            						}
HXDLIN( 121)						if ((x > cameraBounds->xMax)) {
HXLINE( 121)							cameraBounds->xMax = x;
            						}
HXDLIN( 121)						if ((y < cameraBounds->yMin)) {
HXLINE( 121)							cameraBounds->yMin = y;
            						}
HXDLIN( 121)						if ((y > cameraBounds->yMax)) {
HXLINE( 121)							cameraBounds->yMax = y;
            						}
HXDLIN( 121)						if ((z < cameraBounds->zMin)) {
HXLINE( 121)							cameraBounds->zMin = z;
            						}
HXDLIN( 121)						if ((z > cameraBounds->zMax)) {
HXLINE( 121)							cameraBounds->zMax = z;
            						}
            					}
            				}
            			}
HXLINE( 124)			if (( ( ::h3d::pass::DirShadowMap)(__this) )->autoShrink) {
HXLINE( 127)				cameraBounds->zMin = bounds->zMin;
HXLINE( 128)				bounds->intersection(bounds,cameraBounds);
            			}
            			else {
HXLINE( 131)				bounds->load(cameraBounds);
            			}
            		}
HXLINE( 134)		bounds->scaleCenter(((Float)1.01));
            	}
HX_END_LOCAL_FUNC1((void))
HX_END_DEFAULT_FUNC

void DirShadowMap_obj::setGlobals(){
            	HX_STACKFRAME(&_hx_pos_b538f9489ffcca0c_137_setGlobals)
HXLINE( 138)		this->super::setGlobals();
HXLINE( 139)		bool _hx_tmp;
HXDLIN( 139)		if (::hx::IsPointerEq( this->mode,::h3d::pass::RenderMode_obj::Mixed_dyn() )) {
HXLINE( 139)			_hx_tmp = this->ctx->computingStatic;
            		}
            		else {
HXLINE( 139)			_hx_tmp = true;
            		}
HXDLIN( 139)		if (_hx_tmp) {
HXLINE( 140)			{
HXLINE( 140)				 ::h3d::col::Bounds _this = this->lightCamera->orthoBounds;
HXDLIN( 140)				_this->xMin = ((Float)1e20);
HXDLIN( 140)				_this->xMax = ((Float)-1e20);
HXDLIN( 140)				_this->yMin = ((Float)1e20);
HXDLIN( 140)				_this->yMax = ((Float)-1e20);
HXDLIN( 140)				_this->zMin = ((Float)1e20);
HXDLIN( 140)				_this->zMax = ((Float)-1e20);
            			}
HXLINE( 141)			this->calcShadowBounds(this->lightCamera);
HXLINE( 142)			this->lightCamera->update();
            		}
HXLINE( 144)		{
HXLINE( 144)			 ::h3d::Matrix v = this->getShadowProj();
HXDLIN( 144)			this->manager->globals->map->set(this->cameraViewProj_id,v);
            		}
            	}


void DirShadowMap_obj::syncShader( ::h3d::mat::Texture texture){
            	HX_STACKFRAME(&_hx_pos_b538f9489ffcca0c_147_syncShader)
HXLINE( 148)		{
HXLINE( 148)			 ::h3d::shader::DirShadow _this = this->dshader;
HXDLIN( 148)			_this->constModified = true;
HXDLIN( 148)			_this->shadowMap__ = texture;
            		}
HXLINE( 149)		{
HXLINE( 149)			 ::h3d::shader::DirShadow _this1 = this->dshader;
HXDLIN( 149)			 ::hxsl::Channel v;
HXDLIN( 149)			if (::hx::IsPointerEq( this->format,::h3d::mat::Texture_obj::nativeFormat )) {
HXLINE( 149)				v = ::hxsl::Channel_obj::PackedFloat_dyn();
            			}
            			else {
HXLINE( 149)				v = ::hxsl::Channel_obj::R_dyn();
            			}
HXDLIN( 149)			_this1->constModified = true;
HXDLIN( 149)			_this1->shadowMapChannel__ = v;
            		}
HXLINE( 150)		this->dshader->shadowBias__ = this->bias;
HXLINE( 151)		this->dshader->shadowPower__ = this->power;
HXLINE( 152)		this->dshader->shadowProj__ = this->getShadowProj();
HXLINE( 155)		{
HXLINE( 155)			 ::h3d::shader::DirShadow _this2 = this->dshader;
HXDLIN( 155)			_this2->constModified = true;
HXDLIN( 155)			_this2->USE_ESM__ = ::hx::IsPointerEq( this->samplingKind,::h3d::pass::ShadowSamplingKind_obj::ESM_dyn() );
            		}
HXLINE( 156)		this->dshader->shadowPower__ = this->power;
HXLINE( 159)		{
HXLINE( 159)			 ::h3d::shader::DirShadow _this3 = this->dshader;
HXDLIN( 159)			_this3->constModified = true;
HXDLIN( 159)			_this3->USE_PCF__ = ::hx::IsPointerEq( this->samplingKind,::h3d::pass::ShadowSamplingKind_obj::PCF_dyn() );
            		}
HXLINE( 160)		{
HXLINE( 160)			 ::h3d::Vector _this4 = this->dshader->shadowRes__;
HXDLIN( 160)			_this4->x = ( (Float)(texture->width) );
HXDLIN( 160)			_this4->y = ( (Float)(texture->height) );
HXDLIN( 160)			_this4->z = ((Float)0.);
HXDLIN( 160)			_this4->w = ((Float)1.);
            		}
HXLINE( 161)		this->dshader->pcfScale__ = this->pcfScale;
HXLINE( 162)		{
HXLINE( 162)			 ::h3d::shader::DirShadow _this5 = this->dshader;
HXDLIN( 162)			_this5->constModified = true;
HXDLIN( 162)			_this5->pcfQuality__ = this->pcfQuality;
            		}
            	}


 ::haxe::io::Bytes DirShadowMap_obj::saveStaticData(){
            	HX_GC_STACKFRAME(&_hx_pos_b538f9489ffcca0c_165_saveStaticData)
HXLINE( 166)		bool _hx_tmp;
HXDLIN( 166)		if (::hx::IsPointerNotEq( this->mode,::h3d::pass::RenderMode_obj::Mixed_dyn() )) {
HXLINE( 166)			_hx_tmp = ::hx::IsPointerNotEq( this->mode,::h3d::pass::RenderMode_obj::Static_dyn() );
            		}
            		else {
HXLINE( 166)			_hx_tmp = false;
            		}
HXDLIN( 166)		if (_hx_tmp) {
HXLINE( 167)			return null();
            		}
HXLINE( 168)		if (::hx::IsNull( this->staticTexture )) {
HXLINE( 169)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Data not computed",50,55,27,66)));
            		}
HXLINE( 170)		 ::haxe::io::Bytes bytes = ::haxe::zip::Compress_obj::run(this->staticTexture->capturePixels(null(),null(),null())->bytes,9);
HXLINE( 171)		 ::haxe::io::BytesBuffer buffer =  ::haxe::io::BytesBuffer_obj::__alloc( HX_CTX );
HXLINE( 172)		buffer->addInt32(this->staticTexture->width);
HXLINE( 173)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->pos->x));
HXLINE( 174)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->pos->y));
HXLINE( 175)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->pos->z));
HXLINE( 176)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->target->x));
HXLINE( 177)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->target->y));
HXLINE( 178)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->target->z));
HXLINE( 179)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->orthoBounds->xMin));
HXLINE( 180)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->orthoBounds->yMin));
HXLINE( 181)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->orthoBounds->zMin));
HXLINE( 182)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->orthoBounds->xMax));
HXLINE( 183)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->orthoBounds->yMax));
HXLINE( 184)		buffer->addInt32(::haxe::io::FPHelper_obj::floatToI32(this->lightCamera->orthoBounds->zMax));
HXLINE( 185)		buffer->addInt32(bytes->length);
HXLINE( 186)		{
HXLINE( 186)			::Array< unsigned char > b1 = buffer->b;
HXDLIN( 186)			::Array< unsigned char > b2 = bytes->b;
HXDLIN( 186)			{
HXLINE( 186)				int _g = 0;
HXDLIN( 186)				int _g1 = bytes->length;
HXDLIN( 186)				while((_g < _g1)){
HXLINE( 186)					_g = (_g + 1);
HXDLIN( 186)					int i = (_g - 1);
HXDLIN( 186)					buffer->b->push(b2->__get(i));
            				}
            			}
            		}
HXLINE( 187)		return buffer->getBytes();
            	}


bool DirShadowMap_obj::loadStaticData( ::haxe::io::Bytes bytes){
            	HX_GC_STACKFRAME(&_hx_pos_b538f9489ffcca0c_190_loadStaticData)
HXLINE( 191)		bool _hx_tmp;
HXDLIN( 191)		bool _hx_tmp1;
HXDLIN( 191)		if (::hx::IsPointerNotEq( this->mode,::h3d::pass::RenderMode_obj::Mixed_dyn() )) {
HXLINE( 191)			_hx_tmp1 = ::hx::IsPointerNotEq( this->mode,::h3d::pass::RenderMode_obj::Static_dyn() );
            		}
            		else {
HXLINE( 191)			_hx_tmp1 = false;
            		}
HXDLIN( 191)		if (!(_hx_tmp1)) {
HXLINE( 191)			_hx_tmp = ::hx::IsNull( bytes );
            		}
            		else {
HXLINE( 191)			_hx_tmp = true;
            		}
HXDLIN( 191)		if (_hx_tmp) {
HXLINE( 192)			return false;
            		}
HXLINE( 193)		 ::haxe::io::BytesInput buffer =  ::haxe::io::BytesInput_obj::__alloc( HX_CTX ,bytes,null(),null());
HXLINE( 194)		int size = buffer->readInt32();
HXLINE( 195)		if ((size != this->size)) {
HXLINE( 196)			return false;
            		}
HXLINE( 197)		this->lightCamera->pos->x = buffer->readFloat();
HXLINE( 198)		this->lightCamera->pos->y = buffer->readFloat();
HXLINE( 199)		this->lightCamera->pos->z = buffer->readFloat();
HXLINE( 200)		this->lightCamera->target->x = buffer->readFloat();
HXLINE( 201)		this->lightCamera->target->y = buffer->readFloat();
HXLINE( 202)		this->lightCamera->target->z = buffer->readFloat();
HXLINE( 203)		this->lightCamera->orthoBounds->xMin = buffer->readFloat();
HXLINE( 204)		this->lightCamera->orthoBounds->yMin = buffer->readFloat();
HXLINE( 205)		this->lightCamera->orthoBounds->zMin = buffer->readFloat();
HXLINE( 206)		this->lightCamera->orthoBounds->xMax = buffer->readFloat();
HXLINE( 207)		this->lightCamera->orthoBounds->yMax = buffer->readFloat();
HXLINE( 208)		this->lightCamera->orthoBounds->zMax = buffer->readFloat();
HXLINE( 209)		this->lightCamera->update();
HXLINE( 210)		int len = buffer->readInt32();
HXLINE( 211)		 ::haxe::io::Bytes pixels = ::haxe::zip::Uncompress_obj::run(buffer->read(len),null());
HXDLIN( 211)		 ::hxd::Pixels pixels1 =  ::hxd::Pixels_obj::__alloc( HX_CTX ,size,size,pixels,this->format,null());
HXLINE( 212)		if (::hx::IsNotNull( this->staticTexture )) {
HXLINE( 212)			this->staticTexture->dispose();
            		}
HXLINE( 213)		this->staticTexture =  ::h3d::mat::Texture_obj::__alloc( HX_CTX ,size,size,::Array_obj< ::Dynamic>::__new(1)->init(0,::h3d::mat::TextureFlags_obj::Target_dyn()),this->format);
HXLINE( 214)		this->staticTexture->uploadPixels(pixels1,null(),null());
HXLINE( 215)		this->staticTexture->name = HX_("staticTexture",cd,25,f3,25);
HXLINE( 216)		this->staticTexture->preventAutoDispose();
HXLINE( 217)		this->syncShader(this->staticTexture);
HXLINE( 218)		return true;
            	}


void DirShadowMap_obj::draw( ::h3d::pass::PassList passes, ::Dynamic sort){
            	HX_GC_STACKFRAME(&_hx_pos_b538f9489ffcca0c_221_draw)
HXDLIN( 221)		 ::h3d::pass::DirShadowMap _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 222)		if (!(this->enabled)) {
HXLINE( 223)			return;
            		}
HXLINE( 225)		if (!(this->filterPasses(passes))) {
HXLINE( 226)			return;
            		}
HXLINE( 228)		{
            			HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::h3d::pass::DirShadowMap,_gthis) HXARGC(1)
            			bool _hx_run(::Dynamic col){
            				HX_STACKFRAME(&_hx_pos_b538f9489ffcca0c_228_draw)
HXLINE( 228)				return ::h3d::col::Collider_obj::inFrustum(col,_gthis->lightCamera->frustum,null());
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE( 228)			 ::Dynamic f =  ::Dynamic(new _hx_Closure_0(_gthis));
HXDLIN( 228)			::Dynamic prevCollider = null();
HXDLIN( 228)			bool prevResult = true;
HXDLIN( 228)			{
HXLINE( 228)				 ::h3d::pass::PassObject head = null();
HXDLIN( 228)				 ::h3d::pass::PassObject prev = null();
HXDLIN( 228)				 ::h3d::pass::PassObject disc = passes->discarded;
HXDLIN( 228)				 ::h3d::pass::PassObject discQueue = passes->lastDisc;
HXDLIN( 228)				 ::h3d::pass::PassObject cur = passes->current;
HXDLIN( 228)				while(::hx::IsNotNull( cur )){
HXLINE( 228)					::Dynamic col = cur->obj->cullingCollider;
HXDLIN( 228)					bool _hx_tmp;
HXDLIN( 228)					if (::hx::IsNull( col )) {
HXLINE( 228)						_hx_tmp = true;
            					}
            					else {
HXLINE( 228)						if (::hx::IsInstanceNotEq( col,prevCollider )) {
HXLINE( 228)							prevCollider = col;
HXDLIN( 228)							prevResult = ( (bool)(f(col)) );
            						}
HXDLIN( 228)						_hx_tmp = prevResult;
            					}
HXDLIN( 228)					if (_hx_tmp) {
HXLINE( 228)						if (::hx::IsNull( head )) {
HXLINE( 228)							prev = cur;
HXDLIN( 228)							head = prev;
            						}
            						else {
HXLINE( 228)							prev->next = cur;
HXDLIN( 228)							prev = cur;
            						}
            					}
            					else {
HXLINE( 228)						if (::hx::IsNull( disc )) {
HXLINE( 228)							discQueue = cur;
HXDLIN( 228)							disc = discQueue;
            						}
            						else {
HXLINE( 228)							discQueue->next = cur;
HXDLIN( 228)							discQueue = cur;
            						}
            					}
HXDLIN( 228)					cur = cur->next;
            				}
HXDLIN( 228)				if (::hx::IsNotNull( prev )) {
HXLINE( 228)					prev->next = null();
            				}
HXDLIN( 228)				if (::hx::IsNotNull( discQueue )) {
HXLINE( 228)					discQueue->next = null();
            				}
HXDLIN( 228)				passes->current = head;
HXDLIN( 228)				passes->discarded = disc;
HXDLIN( 228)				passes->lastDisc = discQueue;
            			}
            		}
HXLINE( 230)		 ::h3d::mat::Texture texture = this->ctx->textures->allocTarget(HX_("dirShadowMap",8f,37,9d,c1),this->size,this->size,false,this->format,null());
HXLINE( 231)		bool _hx_tmp;
HXDLIN( 231)		if (this->customDepth) {
HXLINE( 231)			bool _hx_tmp1;
HXDLIN( 231)			bool _hx_tmp2;
HXDLIN( 231)			if (::hx::IsNotNull( this->depth )) {
HXLINE( 231)				_hx_tmp2 = (this->depth->width != this->size);
            			}
            			else {
HXLINE( 231)				_hx_tmp2 = true;
            			}
HXDLIN( 231)			if (!(_hx_tmp2)) {
HXLINE( 231)				_hx_tmp1 = (this->depth->height != this->size);
            			}
            			else {
HXLINE( 231)				_hx_tmp1 = true;
            			}
HXDLIN( 231)			if (!(_hx_tmp1)) {
HXLINE( 231)				_hx_tmp = this->depth->isDisposed();
            			}
            			else {
HXLINE( 231)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 231)			_hx_tmp = false;
            		}
HXDLIN( 231)		if (_hx_tmp) {
HXLINE( 232)			if (::hx::IsNotNull( this->depth )) {
HXLINE( 232)				this->depth->dispose();
            			}
HXLINE( 233)			this->depth =  ::h3d::mat::DepthBuffer_obj::__alloc( HX_CTX ,this->size,this->size,null());
            		}
HXLINE( 235)		texture->depthBuffer = this->depth;
HXLINE( 237)		bool _hx_tmp1;
HXDLIN( 237)		if (::hx::IsPointerEq( this->mode,::h3d::pass::RenderMode_obj::Mixed_dyn() )) {
HXLINE( 237)			_hx_tmp1 = this->ctx->computingStatic;
            		}
            		else {
HXLINE( 237)			_hx_tmp1 = true;
            		}
HXDLIN( 237)		if (_hx_tmp1) {
HXLINE( 238)			 ::h3d::Vector ct = this->ctx->camera->target;
HXLINE( 239)			 ::h3d::scene::Light slight;
HXDLIN( 239)			if (::hx::IsNull( this->light )) {
HXLINE( 239)				slight = this->ctx->lightSystem->shadowLight;
            			}
            			else {
HXLINE( 239)				slight = this->light;
            			}
HXLINE( 240)			 ::h3d::Vector ldir;
HXDLIN( 240)			if (::hx::IsNull( slight )) {
HXLINE( 240)				ldir = null();
            			}
            			else {
HXLINE( 240)				ldir = slight->getShadowDirection();
            			}
HXLINE( 241)			if (::hx::IsNull( ldir )) {
HXLINE( 242)				 ::h3d::Vector _this = this->lightCamera->target;
HXDLIN( 242)				_this->x = ( (Float)(0) );
HXDLIN( 242)				_this->y = ( (Float)(0) );
HXDLIN( 242)				_this->z = ( (Float)(-1) );
HXDLIN( 242)				_this->w = ((Float)1.);
            			}
            			else {
HXLINE( 244)				{
HXLINE( 244)					 ::h3d::Vector _this = this->lightCamera->target;
HXDLIN( 244)					_this->x = ldir->x;
HXDLIN( 244)					_this->y = ldir->y;
HXDLIN( 244)					_this->z = ldir->z;
HXDLIN( 244)					_this->w = ((Float)1.);
            				}
HXLINE( 245)				{
HXLINE( 245)					 ::h3d::Vector _this1 = this->lightCamera->target;
HXDLIN( 245)					Float k = (((_this1->x * _this1->x) + (_this1->y * _this1->y)) + (_this1->z * _this1->z));
HXDLIN( 245)					if ((k < ((Float)1e-10))) {
HXLINE( 245)						k = ( (Float)(0) );
            					}
            					else {
HXLINE( 245)						k = (((Float)1.) / ::Math_obj::sqrt(k));
            					}
HXDLIN( 245)					 ::h3d::Vector _this2 = _this1;
HXDLIN( 245)					_this2->x = (_this2->x * k);
HXDLIN( 245)					 ::h3d::Vector _this3 = _this1;
HXDLIN( 245)					_this3->y = (_this3->y * k);
HXDLIN( 245)					 ::h3d::Vector _this4 = _this1;
HXDLIN( 245)					_this4->z = (_this4->z * k);
            				}
            			}
HXLINE( 247)			 ::h3d::Vector fh = this->lightCamera->target;
HXDLIN( 247)			fh->x = (fh->x + ct->x);
HXLINE( 248)			 ::h3d::Vector fh1 = this->lightCamera->target;
HXDLIN( 248)			fh1->y = (fh1->y + ct->y);
HXLINE( 249)			 ::h3d::Vector fh2 = this->lightCamera->target;
HXDLIN( 249)			fh2->z = (fh2->z + ct->z);
HXLINE( 250)			{
HXLINE( 250)				 ::h3d::Vector _this = this->lightCamera->pos;
HXDLIN( 250)				_this->x = ct->x;
HXDLIN( 250)				_this->y = ct->y;
HXDLIN( 250)				_this->z = ct->z;
HXDLIN( 250)				_this->w = ct->w;
            			}
HXLINE( 251)			this->lightCamera->update();
            		}
HXLINE( 254)		this->ctx->engine->pushTarget(texture,null(),null());
HXLINE( 255)		this->ctx->engine->clear(16777215,1,null());
HXLINE( 256)		this->super::draw(passes,sort);
HXLINE( 258)		if (::hx::IsNotNull( this->border )) {
HXLINE( 259)			this->border->render();
            		}
HXLINE( 261)		this->ctx->engine->popTarget();
HXLINE( 263)		bool _hx_tmp2;
HXDLIN( 263)		if (::hx::IsPointerEq( this->mode,::h3d::pass::RenderMode_obj::Mixed_dyn() )) {
HXLINE( 263)			_hx_tmp2 = !(this->ctx->computingStatic);
            		}
            		else {
HXLINE( 263)			_hx_tmp2 = false;
            		}
HXDLIN( 263)		if (_hx_tmp2) {
HXLINE( 264)			 ::h3d::mat::Texture merge = this->ctx->textures->allocTarget(HX_("mergedDirShadowMap",5b,94,b0,ba),this->size,this->size,false,this->format,null());
HXLINE( 265)			( ( ::h3d::shader::MinMaxShader)(this->mergePass->shader) )->texA__ = texture;
HXLINE( 266)			( ( ::h3d::shader::MinMaxShader)(this->mergePass->shader) )->texB__ = this->staticTexture;
HXLINE( 267)			this->ctx->engine->pushTarget(merge,null(),null());
HXLINE( 268)			this->mergePass->render();
HXLINE( 269)			this->ctx->engine->popTarget();
HXLINE( 270)			texture = merge;
            		}
HXLINE( 273)		bool _hx_tmp3;
HXDLIN( 273)		if ((this->blur->radius > 0)) {
HXLINE( 273)			if (::hx::IsPointerEq( this->mode,::h3d::pass::RenderMode_obj::Mixed_dyn() )) {
HXLINE( 273)				_hx_tmp3 = !(this->ctx->computingStatic);
            			}
            			else {
HXLINE( 273)				_hx_tmp3 = true;
            			}
            		}
            		else {
HXLINE( 273)			_hx_tmp3 = false;
            		}
HXDLIN( 273)		if (_hx_tmp3) {
HXLINE( 274)			this->blur->apply(this->ctx,texture,null());
            		}
HXLINE( 276)		this->syncShader(texture);
            	}


void DirShadowMap_obj::computeStatic( ::h3d::pass::PassList passes){
            	HX_STACKFRAME(&_hx_pos_b538f9489ffcca0c_279_computeStatic)
HXLINE( 280)		bool _hx_tmp;
HXDLIN( 280)		if (::hx::IsPointerNotEq( this->mode,::h3d::pass::RenderMode_obj::Static_dyn() )) {
HXLINE( 280)			_hx_tmp = ::hx::IsPointerNotEq( this->mode,::h3d::pass::RenderMode_obj::Mixed_dyn() );
            		}
            		else {
HXLINE( 280)			_hx_tmp = false;
            		}
HXDLIN( 280)		if (_hx_tmp) {
HXLINE( 281)			return;
            		}
HXLINE( 282)		this->draw(passes,null());
HXLINE( 283)		 ::h3d::mat::Texture texture = this->dshader->shadowMap__;
HXLINE( 284)		 ::h3d::mat::Texture old = this->staticTexture;
HXLINE( 285)		this->staticTexture = texture->clone();
HXLINE( 286)		this->staticTexture->name = HX_("StaticDirShadowMap",7d,d1,5c,a4);
HXLINE( 287)		this->staticTexture->preventAutoDispose();
HXLINE( 288)		{
HXLINE( 288)			 ::h3d::shader::DirShadow _this = this->dshader;
HXDLIN( 288)			_this->constModified = true;
HXDLIN( 288)			_this->shadowMap__ = this->staticTexture;
            		}
HXLINE( 289)		if (::hx::IsNotNull( old )) {
HXLINE( 290)			old->dispose();
            		}
            	}



void DirShadowMap_obj::__alloc_dynamic_functions(::hx::Ctx *_hx_ctx,DirShadowMap_obj *_hx_obj) {
	if (!_hx_obj->calcShadowBounds.mPtr) _hx_obj->calcShadowBounds = new __default_calcShadowBounds(_hx_obj);
}
::hx::ObjectPtr< DirShadowMap_obj > DirShadowMap_obj::__new( ::h3d::scene::Light light) {
	::hx::ObjectPtr< DirShadowMap_obj > __this = new DirShadowMap_obj();
	__this->__construct(light);
	return __this;
}

::hx::ObjectPtr< DirShadowMap_obj > DirShadowMap_obj::__alloc(::hx::Ctx *_hx_ctx, ::h3d::scene::Light light) {
	DirShadowMap_obj *__this = (DirShadowMap_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(DirShadowMap_obj), true, "h3d.pass.DirShadowMap"));
	*(void **)__this = DirShadowMap_obj::_hx_vtable;
	h3d::pass::DirShadowMap_obj::__alloc_dynamic_functions(_hx_ctx,__this);
	__this->__construct(light);
	return __this;
}

DirShadowMap_obj::DirShadowMap_obj()
{
	calcShadowBounds = new __default_calcShadowBounds(this);
}

void DirShadowMap_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(DirShadowMap);
	HX_MARK_MEMBER_NAME(customDepth,"customDepth");
	HX_MARK_MEMBER_NAME(depth,"depth");
	HX_MARK_MEMBER_NAME(dshader,"dshader");
	HX_MARK_MEMBER_NAME(border,"border");
	HX_MARK_MEMBER_NAME(mergePass,"mergePass");
	HX_MARK_MEMBER_NAME(autoShrink,"autoShrink");
	HX_MARK_MEMBER_NAME(maxDist,"maxDist");
	HX_MARK_MEMBER_NAME(minDist,"minDist");
	HX_MARK_MEMBER_NAME(calcShadowBounds,"calcShadowBounds");
	 ::h3d::pass::Shadows_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void DirShadowMap_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(customDepth,"customDepth");
	HX_VISIT_MEMBER_NAME(depth,"depth");
	HX_VISIT_MEMBER_NAME(dshader,"dshader");
	HX_VISIT_MEMBER_NAME(border,"border");
	HX_VISIT_MEMBER_NAME(mergePass,"mergePass");
	HX_VISIT_MEMBER_NAME(autoShrink,"autoShrink");
	HX_VISIT_MEMBER_NAME(maxDist,"maxDist");
	HX_VISIT_MEMBER_NAME(minDist,"minDist");
	HX_VISIT_MEMBER_NAME(calcShadowBounds,"calcShadowBounds");
	 ::h3d::pass::Shadows_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val DirShadowMap_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"depth") ) { return ::hx::Val( depth ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"border") ) { return ::hx::Val( border ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"dshader") ) { return ::hx::Val( dshader ); }
		if (HX_FIELD_EQ(inName,"maxDist") ) { return ::hx::Val( maxDist ); }
		if (HX_FIELD_EQ(inName,"minDist") ) { return ::hx::Val( minDist ); }
		if (HX_FIELD_EQ(inName,"dispose") ) { return ::hx::Val( dispose_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"set_mode") ) { return ::hx::Val( set_mode_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_size") ) { return ::hx::Val( set_size_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"mergePass") ) { return ::hx::Val( mergePass ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"autoShrink") ) { return ::hx::Val( autoShrink ); }
		if (HX_FIELD_EQ(inName,"setGlobals") ) { return ::hx::Val( setGlobals_dyn() ); }
		if (HX_FIELD_EQ(inName,"syncShader") ) { return ::hx::Val( syncShader_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"customDepth") ) { return ::hx::Val( customDepth ); }
		if (HX_FIELD_EQ(inName,"set_enabled") ) { return ::hx::Val( set_enabled_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getShadowTex") ) { return ::hx::Val( getShadowTex_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"computeStatic") ) { return ::hx::Val( computeStatic_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"saveStaticData") ) { return ::hx::Val( saveStaticData_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadStaticData") ) { return ::hx::Val( loadStaticData_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"calcShadowBounds") ) { return ::hx::Val( calcShadowBounds ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val DirShadowMap_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"depth") ) { depth=inValue.Cast<  ::h3d::mat::DepthBuffer >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"border") ) { border=inValue.Cast<  ::h3d::pass::Border >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"dshader") ) { dshader=inValue.Cast<  ::h3d::shader::DirShadow >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxDist") ) { maxDist=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"minDist") ) { minDist=inValue.Cast< Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"mergePass") ) { mergePass=inValue.Cast<  ::h3d::pass::ScreenFx >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"autoShrink") ) { autoShrink=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"customDepth") ) { customDepth=inValue.Cast< bool >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"calcShadowBounds") ) { calcShadowBounds=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void DirShadowMap_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("customDepth",92,57,66,6c));
	outFields->push(HX_("depth",03,f1,29,d7));
	outFields->push(HX_("dshader",89,22,83,5b));
	outFields->push(HX_("border",ec,4c,1a,64));
	outFields->push(HX_("mergePass",a9,6f,a5,71));
	outFields->push(HX_("autoShrink",98,43,2c,94));
	outFields->push(HX_("maxDist",2a,c0,99,c2));
	outFields->push(HX_("minDist",18,d6,72,33));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo DirShadowMap_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(DirShadowMap_obj,customDepth),HX_("customDepth",92,57,66,6c)},
	{::hx::fsObject /*  ::h3d::mat::DepthBuffer */ ,(int)offsetof(DirShadowMap_obj,depth),HX_("depth",03,f1,29,d7)},
	{::hx::fsObject /*  ::h3d::shader::DirShadow */ ,(int)offsetof(DirShadowMap_obj,dshader),HX_("dshader",89,22,83,5b)},
	{::hx::fsObject /*  ::h3d::pass::Border */ ,(int)offsetof(DirShadowMap_obj,border),HX_("border",ec,4c,1a,64)},
	{::hx::fsObject /*  ::h3d::pass::ScreenFx */ ,(int)offsetof(DirShadowMap_obj,mergePass),HX_("mergePass",a9,6f,a5,71)},
	{::hx::fsBool,(int)offsetof(DirShadowMap_obj,autoShrink),HX_("autoShrink",98,43,2c,94)},
	{::hx::fsFloat,(int)offsetof(DirShadowMap_obj,maxDist),HX_("maxDist",2a,c0,99,c2)},
	{::hx::fsFloat,(int)offsetof(DirShadowMap_obj,minDist),HX_("minDist",18,d6,72,33)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(DirShadowMap_obj,calcShadowBounds),HX_("calcShadowBounds",aa,5a,83,3f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *DirShadowMap_obj_sStaticStorageInfo = 0;
#endif

static ::String DirShadowMap_obj_sMemberFields[] = {
	HX_("customDepth",92,57,66,6c),
	HX_("depth",03,f1,29,d7),
	HX_("dshader",89,22,83,5b),
	HX_("border",ec,4c,1a,64),
	HX_("mergePass",a9,6f,a5,71),
	HX_("autoShrink",98,43,2c,94),
	HX_("maxDist",2a,c0,99,c2),
	HX_("minDist",18,d6,72,33),
	HX_("set_mode",60,e8,78,76),
	HX_("set_enabled",a4,6b,98,0e),
	HX_("set_size",be,b5,6b,7a),
	HX_("dispose",9f,80,4c,bb),
	HX_("getShadowTex",71,16,fc,03),
	HX_("calcShadowBounds",aa,5a,83,3f),
	HX_("setGlobals",2e,2a,18,67),
	HX_("syncShader",e0,a3,bd,0f),
	HX_("saveStaticData",95,2b,89,a2),
	HX_("loadStaticData",be,57,c0,3a),
	HX_("draw",04,2c,70,42),
	HX_("computeStatic",85,0b,72,70),
	::String(null()) };

::hx::Class DirShadowMap_obj::__mClass;

void DirShadowMap_obj::__register()
{
	DirShadowMap_obj _hx_dummy;
	DirShadowMap_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("h3d.pass.DirShadowMap",f7,02,d6,11);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(DirShadowMap_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< DirShadowMap_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = DirShadowMap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = DirShadowMap_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace h3d
} // end namespace pass
