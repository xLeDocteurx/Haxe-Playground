#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_hxd_Math
#include <hxd/Math.h>
#endif
#ifndef INCLUDED_hxd_Timer
#include <hxd/Timer.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_13_get_POSITIVE_INFINITY,"hxd.Math","get_POSITIVE_INFINITY",0x3d846319,"hxd.Math.get_POSITIVE_INFINITY","hxd/Math.hx",13,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_17_get_NEGATIVE_INFINITY,"hxd.Math","get_NEGATIVE_INFINITY",0x5e850bdd,"hxd.Math.get_NEGATIVE_INFINITY","hxd/Math.hx",17,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_21_get_NaN,"hxd.Math","get_NaN",0x323b1a06,"hxd.Math.get_NaN","hxd/Math.hx",21,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_25_isNaN,"hxd.Math","isNaN",0x589226c5,"hxd.Math.isNaN","hxd/Math.hx",25,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_29_fmt,"hxd.Math","fmt",0x7a149821,"hxd.Math.fmt","hxd/Math.hx",29,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_48_floor,"hxd.Math","floor",0x99d701a0,"hxd.Math.floor","hxd/Math.hx",48,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_52_ceil,"hxd.Math","ceil",0x55eec5b1,"hxd.Math.ceil","hxd/Math.hx",52,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_56_round,"hxd.Math","round",0x84a62822,"hxd.Math.round","hxd/Math.hx",56,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_60_clamp,"hxd.Math","clamp",0xdf98a2cf,"hxd.Math.clamp","hxd/Math.hx",60,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_64_pow,"hxd.Math","pow",0x7a1c306c,"hxd.Math.pow","hxd/Math.hx",64,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_68_cos,"hxd.Math","cos",0x7a12531b,"hxd.Math.cos","hxd/Math.hx",68,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_72_sin,"hxd.Math","sin",0x7a1e71ec,"hxd.Math.sin","hxd/Math.hx",72,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_76_tan,"hxd.Math","tan",0x7a1f2d35,"hxd.Math.tan","hxd/Math.hx",76,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_80_acos,"hxd.Math","acos",0x549ad932,"hxd.Math.acos","hxd/Math.hx",80,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_84_asin,"hxd.Math","asin",0x54a6f803,"hxd.Math.asin","hxd/Math.hx",84,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_88_atan,"hxd.Math","atan",0x54a7b34c,"hxd.Math.atan","hxd/Math.hx",88,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_92_sqrt,"hxd.Math","sqrt",0x608b528c,"hxd.Math.sqrt","hxd/Math.hx",92,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_96_invSqrt,"hxd.Math","invSqrt",0x3d957e45,"hxd.Math.invSqrt","hxd/Math.hx",96,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_100_atan2,"hxd.Math","atan2",0xbe152f66,"hxd.Math.atan2","hxd/Math.hx",100,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_104_abs,"hxd.Math","abs",0x7a10c346,"hxd.Math.abs","hxd/Math.hx",104,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_108_max,"hxd.Math","max",0x7a19dd78,"hxd.Math.max","hxd/Math.hx",108,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_112_min,"hxd.Math","min",0x7a19e466,"hxd.Math.min","hxd/Math.hx",112,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_116_iabs,"hxd.Math","iabs",0x59e2fe55,"hxd.Math.iabs","hxd/Math.hx",116,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_120_imax,"hxd.Math","imax",0x59ec1887,"hxd.Math.imax","hxd/Math.hx",120,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_124_imin,"hxd.Math","imin",0x59ec1f75,"hxd.Math.imin","hxd/Math.hx",124,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_128_iclamp,"hxd.Math","iclamp",0x04baff9e,"hxd.Math.iclamp","hxd/Math.hx",128,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_135_lerp,"hxd.Math","lerp",0x5be1b923,"hxd.Math.lerp","hxd/Math.hx",135,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_142_lerpTime,"hxd.Math","lerpTime",0xe08e7ed0,"hxd.Math.lerpTime","hxd/Math.hx",142,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_145_bitCount,"hxd.Math","bitCount",0x407c616e,"hxd.Math.bitCount","hxd/Math.hx",145,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_152_isPOT,"hxd.Math","isPOT",0x58939b9f,"hxd.Math.isPOT","hxd/Math.hx",152,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_155_nextPOT,"hxd.Math","nextPOT",0xb0ce9b36,"hxd.Math.nextPOT","hxd/Math.hx",155,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_166_distanceSq,"hxd.Math","distanceSq",0x364ac2df,"hxd.Math.distanceSq","hxd/Math.hx",166,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_170_distance,"hxd.Math","distance",0x79e1ffe1,"hxd.Math.distance","hxd/Math.hx",170,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_176_colorLerp,"hxd.Math","colorLerp",0x4094474e,"hxd.Math.colorLerp","hxd/Math.hx",176,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_195_angle,"hxd.Math","angle",0xba2273a7,"hxd.Math.angle","hxd/Math.hx",195,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_202_angleLerp,"hxd.Math","angleLerp",0xe24c11be,"hxd.Math.angleLerp","hxd/Math.hx",202,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_208_angleMove,"hxd.Math","angleMove",0xe2fce258,"hxd.Math.angleMove","hxd/Math.hx",208,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_216_valueMove,"hxd.Math","valueMove",0xb25c44f6,"hxd.Math.valueMove","hxd/Math.hx",216,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_227_shuffle,"hxd.Math","shuffle",0xf06812cd,"hxd.Math.shuffle","hxd/Math.hx",227,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_239_random,"hxd.Math","random",0x7878cbaf,"hxd.Math.random","hxd/Math.hx",239,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_246_srand,"hxd.Math","srand",0x19f9336c,"hxd.Math.srand","hxd/Math.hx",246,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_256_b2f,"hxd.Math","b2f",0x7a115baa,"hxd.Math.b2f","hxd/Math.hx",256,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_265_f2b,"hxd.Math","f2b",0x7a1464aa,"hxd.Math.f2b","hxd/Math.hx",265,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_271_umod,"hxd.Math","umod",0x61dab419,"hxd.Math.umod","hxd/Math.hx",271,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_279_ufmod,"hxd.Math","ufmod",0x38e0e8e5,"hxd.Math.ufmod","hxd/Math.hx",279,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_288_degToRad,"hxd.Math","degToRad",0xa39cfc20,"hxd.Math.degToRad","hxd/Math.hx",288,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_295_radToDeg,"hxd.Math","radToDeg",0xeaecada2,"hxd.Math.radToDeg","hxd/Math.hx",295,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_5_boot,"hxd.Math","boot",0x554d2ade,"hxd.Math.boot","hxd/Math.hx",5,0xbdc330db)
HX_LOCAL_STACK_FRAME(_hx_pos_59434ab0da9e96d9_6_boot,"hxd.Math","boot",0x554d2ade,"hxd.Math.boot","hxd/Math.hx",6,0xbdc330db)
namespace hxd{

void Math_obj::__construct() { }

Dynamic Math_obj::__CreateEmpty() { return new Math_obj; }

void *Math_obj::_hx_vtable = 0;

Dynamic Math_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Math_obj > _hx_result = new Math_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Math_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4c7e003c;
}

Float Math_obj::PI;

Float Math_obj::EPSILON;

Float Math_obj::get_POSITIVE_INFINITY(){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_13_get_POSITIVE_INFINITY)
HXDLIN(  13)		return ::Math_obj::POSITIVE_INFINITY;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Math_obj,get_POSITIVE_INFINITY,return )

Float Math_obj::get_NEGATIVE_INFINITY(){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_17_get_NEGATIVE_INFINITY)
HXDLIN(  17)		return ::Math_obj::NEGATIVE_INFINITY;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Math_obj,get_NEGATIVE_INFINITY,return )

Float Math_obj::get_NaN(){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_21_get_NaN)
HXDLIN(  21)		return ::Math_obj::NaN;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Math_obj,get_NaN,return )

bool Math_obj::isNaN(Float v){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_25_isNaN)
HXDLIN(  25)		return ::Math_obj::isNaN(v);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,isNaN,return )

Float Math_obj::fmt(Float v){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_29_fmt)
HXLINE(  30)		Float neg;
HXLINE(  31)		if ((v < 0)) {
HXLINE(  32)			neg = ((Float)-1.0);
HXLINE(  33)			v = -(v);
            		}
            		else {
HXLINE(  35)			neg = ((Float)1.0);
            		}
HXLINE(  36)		bool _hx_tmp;
HXDLIN(  36)		if (!(::Math_obj::isNaN(v))) {
HXLINE(  36)			_hx_tmp = !(::Math_obj::isFinite(v));
            		}
            		else {
HXLINE(  36)			_hx_tmp = true;
            		}
HXDLIN(  36)		if (_hx_tmp) {
HXLINE(  37)			return v;
            		}
HXLINE(  38)		int digits = ::Std_obj::_hx_int((( (Float)(4) ) - (::Math_obj::log(v) / ::Math_obj::log(( (Float)(10) )))));
HXLINE(  39)		if ((digits < 1)) {
HXLINE(  40)			digits = 1;
            		}
            		else {
HXLINE(  41)			if ((digits >= 10)) {
HXLINE(  42)				return ((Float)0.);
            			}
            		}
HXLINE(  43)		Float exp = ::Math_obj::pow(( (Float)(10) ),( (Float)(digits) ));
HXLINE(  44)		return ((::Math_obj::ffloor(((v * exp) + ((Float).49999))) * neg) / exp);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,fmt,return )

int Math_obj::floor(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_48_floor)
HXDLIN(  48)		return ::Math_obj::floor(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,floor,return )

int Math_obj::ceil(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_52_ceil)
HXDLIN(  52)		return ::Math_obj::ceil(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,ceil,return )

int Math_obj::round(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_56_round)
HXDLIN(  56)		return ::Math_obj::round(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,round,return )

Float Math_obj::clamp(Float f,::hx::Null< Float >  __o_min,::hx::Null< Float >  __o_max){
            		Float min = __o_min.Default(((Float)0.));
            		Float max = __o_max.Default(((Float)1.));
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_60_clamp)
HXDLIN(  60)		if ((f < min)) {
HXDLIN(  60)			return min;
            		}
            		else {
HXDLIN(  60)			if ((f > max)) {
HXDLIN(  60)				return max;
            			}
            			else {
HXDLIN(  60)				return f;
            			}
            		}
HXDLIN(  60)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Math_obj,clamp,return )

Float Math_obj::pow(Float v,Float p){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_64_pow)
HXDLIN(  64)		return ::Math_obj::pow(v,p);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Math_obj,pow,return )

Float Math_obj::cos(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_68_cos)
HXDLIN(  68)		return ::Math_obj::cos(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,cos,return )

Float Math_obj::sin(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_72_sin)
HXDLIN(  72)		return ::Math_obj::sin(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,sin,return )

Float Math_obj::tan(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_76_tan)
HXDLIN(  76)		return ::Math_obj::tan(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,tan,return )

Float Math_obj::acos(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_80_acos)
HXDLIN(  80)		return ::Math_obj::acos(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,acos,return )

Float Math_obj::asin(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_84_asin)
HXDLIN(  84)		return ::Math_obj::asin(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,asin,return )

Float Math_obj::atan(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_88_atan)
HXDLIN(  88)		return ::Math_obj::atan(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,atan,return )

Float Math_obj::sqrt(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_92_sqrt)
HXDLIN(  92)		return ::Math_obj::sqrt(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,sqrt,return )

Float Math_obj::invSqrt(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_96_invSqrt)
HXDLIN(  96)		return (((Float)1.) / ::Math_obj::sqrt(f));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,invSqrt,return )

Float Math_obj::atan2(Float dy,Float dx){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_100_atan2)
HXDLIN( 100)		return ::Math_obj::atan2(dy,dx);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Math_obj,atan2,return )

Float Math_obj::abs(Float f){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_104_abs)
HXDLIN( 104)		if ((f < 0)) {
HXDLIN( 104)			return -(f);
            		}
            		else {
HXDLIN( 104)			return f;
            		}
HXDLIN( 104)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,abs,return )

Float Math_obj::max(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_108_max)
HXDLIN( 108)		if ((a < b)) {
HXDLIN( 108)			return b;
            		}
            		else {
HXDLIN( 108)			return a;
            		}
HXDLIN( 108)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Math_obj,max,return )

Float Math_obj::min(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_112_min)
HXDLIN( 112)		if ((a > b)) {
HXDLIN( 112)			return b;
            		}
            		else {
HXDLIN( 112)			return a;
            		}
HXDLIN( 112)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Math_obj,min,return )

int Math_obj::iabs(int i){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_116_iabs)
HXDLIN( 116)		if ((i < 0)) {
HXDLIN( 116)			return -(i);
            		}
            		else {
HXDLIN( 116)			return i;
            		}
HXDLIN( 116)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,iabs,return )

int Math_obj::imax(int a,int b){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_120_imax)
HXDLIN( 120)		if ((a < b)) {
HXDLIN( 120)			return b;
            		}
            		else {
HXDLIN( 120)			return a;
            		}
HXDLIN( 120)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Math_obj,imax,return )

int Math_obj::imin(int a,int b){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_124_imin)
HXDLIN( 124)		if ((a > b)) {
HXDLIN( 124)			return b;
            		}
            		else {
HXDLIN( 124)			return a;
            		}
HXDLIN( 124)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Math_obj,imin,return )

int Math_obj::iclamp(int v,int min,int max){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_128_iclamp)
HXDLIN( 128)		if ((v < min)) {
HXDLIN( 128)			return min;
            		}
            		else {
HXDLIN( 128)			if ((v > max)) {
HXDLIN( 128)				return max;
            			}
            			else {
HXDLIN( 128)				return v;
            			}
            		}
HXDLIN( 128)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Math_obj,iclamp,return )

Float Math_obj::lerp(Float a,Float b,Float k){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_135_lerp)
HXDLIN( 135)		return (a + (k * (b - a)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Math_obj,lerp,return )

Float Math_obj::lerpTime(Float a,Float b,Float k,Float dt){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_142_lerpTime)
HXDLIN( 142)		return (a + ((( (Float)(1) ) - ::Math_obj::pow((( (Float)(1) ) - k),(dt * ::hxd::Timer_obj::wantedFPS))) * (b - a)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Math_obj,lerpTime,return )

int Math_obj::bitCount(int v){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_145_bitCount)
HXLINE( 146)		v = (v - ((v >> 1) & (int)1431655765));
HXLINE( 147)		v = ((v & 858993459) + ((v >> 2) & 858993459));
HXLINE( 148)		return ((((v + (v >> 4)) & 252645135) * 16843009) >> 24);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,bitCount,return )

bool Math_obj::isPOT(int v){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_152_isPOT)
HXDLIN( 152)		return ((v & (v - 1)) == 0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,isPOT,return )

int Math_obj::nextPOT(int v){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_155_nextPOT)
HXLINE( 156)		v = (v - 1);
HXLINE( 157)		v = (v | (v >> 1));
HXLINE( 158)		v = (v | (v >> 2));
HXLINE( 159)		v = (v | (v >> 4));
HXLINE( 160)		v = (v | (v >> 8));
HXLINE( 161)		v = (v | (v >> 16));
HXLINE( 162)		v = (v + 1);
HXDLIN( 162)		return v;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,nextPOT,return )

Float Math_obj::distanceSq(Float dx,Float dy,::hx::Null< Float >  __o_dz){
            		Float dz = __o_dz.Default(((Float)0.));
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_166_distanceSq)
HXDLIN( 166)		return (((dx * dx) + (dy * dy)) + (dz * dz));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Math_obj,distanceSq,return )

Float Math_obj::distance(Float dx,Float dy,::hx::Null< Float >  __o_dz){
            		Float dz = __o_dz.Default(((Float)0.));
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_170_distance)
HXDLIN( 170)		return ::Math_obj::sqrt((((dx * dx) + (dy * dy)) + (dz * dz)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Math_obj,distance,return )

int Math_obj::colorLerp(int c1,int c2,Float k){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_176_colorLerp)
HXLINE( 177)		int a1 = ::hx::UShr(c1,24);
HXLINE( 178)		int r1 = ((c1 >> 16) & 255);
HXLINE( 179)		int g1 = ((c1 >> 8) & 255);
HXLINE( 180)		int b1 = (c1 & 255);
HXLINE( 181)		int a2 = ::hx::UShr(c2,24);
HXLINE( 182)		int r2 = ((c2 >> 16) & 255);
HXLINE( 183)		int g2 = ((c2 >> 8) & 255);
HXLINE( 184)		int b2 = (c2 & 255);
HXLINE( 185)		int a = ::Std_obj::_hx_int(((( (Float)(a1) ) * (( (Float)(1) ) - k)) + (( (Float)(a2) ) * k)));
HXLINE( 186)		int r = ::Std_obj::_hx_int(((( (Float)(r1) ) * (( (Float)(1) ) - k)) + (( (Float)(r2) ) * k)));
HXLINE( 187)		int g = ::Std_obj::_hx_int(((( (Float)(g1) ) * (( (Float)(1) ) - k)) + (( (Float)(g2) ) * k)));
HXLINE( 188)		int b = ::Std_obj::_hx_int(((( (Float)(b1) ) * (( (Float)(1) ) - k)) + (( (Float)(b2) ) * k)));
HXLINE( 189)		return ((((a << 24) | (r << 16)) | (g << 8)) | b);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Math_obj,colorLerp,return )

Float Math_obj::angle(Float da){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_195_angle)
HXLINE( 196)		da = ::hx::Mod(da,((Float)6.28318530717958623));
HXLINE( 197)		if ((da > ((Float)3.14159265358979323))) {
HXLINE( 197)			da = (da - ((Float)6.28318530717958623));
            		}
            		else {
HXLINE( 197)			if ((da <= ((Float)-3.14159265358979312))) {
HXLINE( 197)				da = (da + ((Float)6.28318530717958623));
            			}
            		}
HXLINE( 198)		return da;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,angle,return )

Float Math_obj::angleLerp(Float a,Float b,Float k){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_202_angleLerp)
HXDLIN( 202)		Float da = (b - a);
HXDLIN( 202)		da = ::hx::Mod(da,((Float)6.28318530717958623));
HXDLIN( 202)		if ((da > ((Float)3.14159265358979323))) {
HXDLIN( 202)			da = (da - ((Float)6.28318530717958623));
            		}
            		else {
HXDLIN( 202)			if ((da <= ((Float)-3.14159265358979312))) {
HXDLIN( 202)				da = (da + ((Float)6.28318530717958623));
            			}
            		}
HXDLIN( 202)		return (a + (da * k));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Math_obj,angleLerp,return )

Float Math_obj::angleMove(Float a,Float b,Float max){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_208_angleMove)
HXLINE( 209)		Float da = (b - a);
HXDLIN( 209)		da = ::hx::Mod(da,((Float)6.28318530717958623));
HXDLIN( 209)		if ((da > ((Float)3.14159265358979323))) {
HXLINE( 209)			da = (da - ((Float)6.28318530717958623));
            		}
            		else {
HXLINE( 209)			if ((da <= ((Float)-3.14159265358979312))) {
HXLINE( 209)				da = (da + ((Float)6.28318530717958623));
            			}
            		}
HXDLIN( 209)		Float da1 = da;
HXLINE( 210)		bool _hx_tmp;
HXDLIN( 210)		if ((da1 > -(max))) {
HXLINE( 210)			_hx_tmp = (da1 < max);
            		}
            		else {
HXLINE( 210)			_hx_tmp = false;
            		}
HXDLIN( 210)		if (_hx_tmp) {
HXLINE( 210)			return b;
            		}
            		else {
HXLINE( 210)			Float _hx_tmp;
HXDLIN( 210)			if ((da1 < 0)) {
HXLINE( 210)				_hx_tmp = -(max);
            			}
            			else {
HXLINE( 210)				_hx_tmp = max;
            			}
HXDLIN( 210)			return (a + _hx_tmp);
            		}
HXDLIN( 210)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Math_obj,angleMove,return )

Float Math_obj::valueMove(Float v,Float target,Float max){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_216_valueMove)
HXLINE( 217)		if ((v < target)) {
HXLINE( 218)			v = (v + max);
HXLINE( 219)			if ((v > target)) {
HXLINE( 219)				v = target;
            			}
            		}
            		else {
HXLINE( 220)			if ((v > target)) {
HXLINE( 221)				v = (v - max);
HXLINE( 222)				if ((v < target)) {
HXLINE( 222)					v = target;
            				}
            			}
            		}
HXLINE( 224)		return v;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Math_obj,valueMove,return )

void Math_obj::shuffle(::cpp::VirtualArray a){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_227_shuffle)
HXLINE( 228)		int len = a->get_length();
HXLINE( 229)		{
HXLINE( 229)			int _g = 0;
HXDLIN( 229)			int _g1 = len;
HXDLIN( 229)			while((_g < _g1)){
HXLINE( 229)				_g = (_g + 1);
HXDLIN( 229)				int i = (_g - 1);
HXLINE( 230)				int x = ::Std_obj::random(len);
HXLINE( 231)				int y = ::Std_obj::random(len);
HXLINE( 232)				 ::Dynamic tmp = a->__get(x);
HXLINE( 233)				a->set(x,a->__get(y));
HXLINE( 234)				a->set(y,tmp);
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,shuffle,(void))

Float Math_obj::random(::hx::Null< Float >  __o_max){
            		Float max = __o_max.Default(((Float)1.0));
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_239_random)
HXDLIN( 239)		return (::Math_obj::random() * max);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,random,return )

Float Math_obj::srand(::hx::Null< Float >  __o_max){
            		Float max = __o_max.Default(((Float)1.0));
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_246_srand)
HXDLIN( 246)		return ((::Math_obj::random() - ((Float)0.5)) * (max * ( (Float)(2) )));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,srand,return )

Float Math_obj::b2f(int v){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_256_b2f)
HXDLIN( 256)		return (( (Float)((v & 255)) ) * ((Float)0.0039215686274509803921568627451));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,b2f,return )

int Math_obj::f2b(Float v){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_265_f2b)
HXDLIN( 265)		Float min = ((Float)0.);
HXDLIN( 265)		Float max = ((Float)1.);
HXDLIN( 265)		Float _hx_tmp;
HXDLIN( 265)		if ((v < min)) {
HXDLIN( 265)			_hx_tmp = min;
            		}
            		else {
HXDLIN( 265)			if ((v > max)) {
HXDLIN( 265)				_hx_tmp = max;
            			}
            			else {
HXDLIN( 265)				_hx_tmp = v;
            			}
            		}
HXDLIN( 265)		return ::Std_obj::_hx_int((_hx_tmp * ((Float)255.0)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,f2b,return )

int Math_obj::umod(int value,int modulo){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_271_umod)
HXLINE( 272)		int r = ::hx::Mod(value,modulo);
HXLINE( 273)		if ((r >= 0)) {
HXLINE( 273)			return r;
            		}
            		else {
HXLINE( 273)			return (r + modulo);
            		}
HXDLIN( 273)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Math_obj,umod,return )

Float Math_obj::ufmod(Float value,Float modulo){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_279_ufmod)
HXLINE( 280)		Float r = ::hx::Mod(value,modulo);
HXLINE( 281)		if ((r >= 0)) {
HXLINE( 281)			return r;
            		}
            		else {
HXLINE( 281)			return (r + modulo);
            		}
HXDLIN( 281)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Math_obj,ufmod,return )

Float Math_obj::degToRad(Float deg){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_288_degToRad)
HXDLIN( 288)		return ((deg * ((Float)3.14159265358979323)) / ((Float)180.0));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,degToRad,return )

Float Math_obj::radToDeg(Float rad){
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_295_radToDeg)
HXDLIN( 295)		return ((rad * ((Float)180.0)) / ((Float)3.14159265358979323));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Math_obj,radToDeg,return )


Math_obj::Math_obj()
{
}

bool Math_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"NaN") ) { if (inCallProp == ::hx::paccAlways) { outValue = ( get_NaN() ); return true; } }
		if (HX_FIELD_EQ(inName,"fmt") ) { outValue = fmt_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"pow") ) { outValue = pow_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"cos") ) { outValue = cos_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sin") ) { outValue = sin_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"tan") ) { outValue = tan_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"abs") ) { outValue = abs_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"max") ) { outValue = max_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"min") ) { outValue = min_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"b2f") ) { outValue = b2f_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"f2b") ) { outValue = f2b_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"ceil") ) { outValue = ceil_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"acos") ) { outValue = acos_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"asin") ) { outValue = asin_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"atan") ) { outValue = atan_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sqrt") ) { outValue = sqrt_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"iabs") ) { outValue = iabs_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"imax") ) { outValue = imax_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"imin") ) { outValue = imin_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"lerp") ) { outValue = lerp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"umod") ) { outValue = umod_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"isNaN") ) { outValue = isNaN_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"floor") ) { outValue = floor_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"round") ) { outValue = round_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"clamp") ) { outValue = clamp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"atan2") ) { outValue = atan2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isPOT") ) { outValue = isPOT_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"angle") ) { outValue = angle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"srand") ) { outValue = srand_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"ufmod") ) { outValue = ufmod_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"iclamp") ) { outValue = iclamp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"random") ) { outValue = random_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"get_NaN") ) { outValue = get_NaN_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"invSqrt") ) { outValue = invSqrt_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"nextPOT") ) { outValue = nextPOT_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"shuffle") ) { outValue = shuffle_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"lerpTime") ) { outValue = lerpTime_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"bitCount") ) { outValue = bitCount_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"distance") ) { outValue = distance_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"degToRad") ) { outValue = degToRad_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"radToDeg") ) { outValue = radToDeg_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"colorLerp") ) { outValue = colorLerp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"angleLerp") ) { outValue = angleLerp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"angleMove") ) { outValue = angleMove_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"valueMove") ) { outValue = valueMove_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"distanceSq") ) { outValue = distanceSq_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"POSITIVE_INFINITY") ) { if (inCallProp == ::hx::paccAlways) { outValue = ( get_POSITIVE_INFINITY() ); return true; } }
		if (HX_FIELD_EQ(inName,"NEGATIVE_INFINITY") ) { if (inCallProp == ::hx::paccAlways) { outValue = ( get_NEGATIVE_INFINITY() ); return true; } }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"get_POSITIVE_INFINITY") ) { outValue = get_POSITIVE_INFINITY_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_NEGATIVE_INFINITY") ) { outValue = get_NEGATIVE_INFINITY_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Math_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Math_obj_sStaticStorageInfo[] = {
	{::hx::fsFloat,(void *) &Math_obj::PI,HX_("PI",f9,45,00,00)},
	{::hx::fsFloat,(void *) &Math_obj::EPSILON,HX_("EPSILON",4a,89,92,2c)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Math_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Math_obj::PI,"PI");
	HX_MARK_MEMBER_NAME(Math_obj::EPSILON,"EPSILON");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Math_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Math_obj::PI,"PI");
	HX_VISIT_MEMBER_NAME(Math_obj::EPSILON,"EPSILON");
};

#endif

::hx::Class Math_obj::__mClass;

static ::String Math_obj_sStaticFields[] = {
	HX_("PI",f9,45,00,00),
	HX_("EPSILON",4a,89,92,2c),
	HX_("get_POSITIVE_INFINITY",45,4b,cc,f0),
	HX_("get_NEGATIVE_INFINITY",09,f4,cc,11),
	HX_("get_NaN",32,4d,b0,26),
	HX_("isNaN",f1,f6,51,c1),
	HX_("fmt",4d,c5,4d,00),
	HX_("floor",cc,d1,96,02),
	HX_("ceil",05,1f,bd,41),
	HX_("round",4e,f8,65,ed),
	HX_("clamp",fb,72,58,48),
	HX_("pow",98,5d,55,00),
	HX_("cos",47,80,4b,00),
	HX_("sin",18,9f,57,00),
	HX_("tan",61,5a,58,00),
	HX_("acos",86,32,69,40),
	HX_("asin",57,51,75,40),
	HX_("atan",a0,0c,76,40),
	HX_("sqrt",e0,ab,59,4c),
	HX_("invSqrt",71,b1,0a,32),
	HX_("atan2",92,ff,d4,26),
	HX_("abs",72,f0,49,00),
	HX_("max",a4,0a,53,00),
	HX_("min",92,11,53,00),
	HX_("iabs",a9,57,b1,45),
	HX_("imax",db,71,ba,45),
	HX_("imin",c9,78,ba,45),
	HX_("iclamp",f2,55,d1,43),
	HX_("lerp",77,12,b0,47),
	HX_("lerpTime",24,12,a6,d2),
	HX_("bitCount",c2,f4,93,32),
	HX_("isPOT",cb,6b,53,c1),
	HX_("nextPOT",62,ce,43,a5),
	HX_("distanceSq",33,d3,ec,8b),
	HX_("distance",35,93,f9,6b),
	HX_("colorLerp",7a,9d,1d,23),
	HX_("angle",d3,43,e2,22),
	HX_("angleLerp",ea,67,d5,c4),
	HX_("angleMove",84,38,86,c5),
	HX_("valueMove",22,9b,e5,94),
	HX_("shuffle",f9,45,dd,e4),
	HX_("random",03,22,8f,b7),
	HX_("srand",98,03,b9,82),
	HX_("b2f",d6,88,4a,00),
	HX_("f2b",d6,91,4d,00),
	HX_("umod",6d,0d,a9,4d),
	HX_("ufmod",11,b9,a0,a1),
	HX_("degToRad",74,8f,b4,95),
	HX_("radToDeg",f6,40,04,dd),
	::String(null())
};

void Math_obj::__register()
{
	Math_obj _hx_dummy;
	Math_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hxd.Math",42,39,dc,65);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Math_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Math_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Math_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Math_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Math_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Math_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Math_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Math_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_5_boot)
HXDLIN(   5)		PI = ((Float)3.14159265358979323);
            	}
{
            	HX_STACKFRAME(&_hx_pos_59434ab0da9e96d9_6_boot)
HXDLIN(   6)		EPSILON = ((Float)1e-10);
            	}
}

} // end namespace hxd
