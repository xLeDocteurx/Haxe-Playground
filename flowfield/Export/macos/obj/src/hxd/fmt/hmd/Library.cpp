#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_h2d_BlendMode
#include <h2d/BlendMode.h>
#endif
#ifndef INCLUDED_h3d_Matrix
#include <h3d/Matrix.h>
#endif
#ifndef INCLUDED_h3d_Vector
#include <h3d/Vector.h>
#endif
#ifndef INCLUDED_h3d_anim_AnimatedObject
#include <h3d/anim/AnimatedObject.h>
#endif
#ifndef INCLUDED_h3d_anim_Animation
#include <h3d/anim/Animation.h>
#endif
#ifndef INCLUDED_h3d_anim_BufferAnimation
#include <h3d/anim/BufferAnimation.h>
#endif
#ifndef INCLUDED_h3d_anim_BufferObject
#include <h3d/anim/BufferObject.h>
#endif
#ifndef INCLUDED_h3d_anim_DataLayout
#include <h3d/anim/DataLayout.h>
#endif
#ifndef INCLUDED_h3d_anim_Joint
#include <h3d/anim/Joint.h>
#endif
#ifndef INCLUDED_h3d_anim_LinearAnimation
#include <h3d/anim/LinearAnimation.h>
#endif
#ifndef INCLUDED_h3d_anim_LinearFrame
#include <h3d/anim/LinearFrame.h>
#endif
#ifndef INCLUDED_h3d_anim_Skin
#include <h3d/anim/Skin.h>
#endif
#ifndef INCLUDED_h3d_col_Bounds
#include <h3d/col/Bounds.h>
#endif
#ifndef INCLUDED_h3d_col_Collider
#include <h3d/col/Collider.h>
#endif
#ifndef INCLUDED_h3d_col_Point
#include <h3d/col/Point.h>
#endif
#ifndef INCLUDED_h3d_mat_BaseMaterial
#include <h3d/mat/BaseMaterial.h>
#endif
#ifndef INCLUDED_h3d_mat_Material
#include <h3d/mat/Material.h>
#endif
#ifndef INCLUDED_h3d_mat_MaterialSetup
#include <h3d/mat/MaterialSetup.h>
#endif
#ifndef INCLUDED_h3d_mat_Texture
#include <h3d/mat/Texture.h>
#endif
#ifndef INCLUDED_h3d_prim_HMDModel
#include <h3d/prim/HMDModel.h>
#endif
#ifndef INCLUDED_h3d_prim_MeshPrimitive
#include <h3d/prim/MeshPrimitive.h>
#endif
#ifndef INCLUDED_h3d_prim_Primitive
#include <h3d/prim/Primitive.h>
#endif
#ifndef INCLUDED_h3d_scene_Mesh
#include <h3d/scene/Mesh.h>
#endif
#ifndef INCLUDED_h3d_scene_MultiMaterial
#include <h3d/scene/MultiMaterial.h>
#endif
#ifndef INCLUDED_h3d_scene_Object
#include <h3d/scene/Object.h>
#endif
#ifndef INCLUDED_h3d_scene_Skin
#include <h3d/scene/Skin.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Error
#include <haxe/io/Error.h>
#endif
#ifndef INCLUDED_haxe_io_FPHelper
#include <haxe/io/FPHelper.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_Animation
#include <hxd/fmt/hmd/Animation.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_AnimationEvent
#include <hxd/fmt/hmd/AnimationEvent.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_AnimationFlag
#include <hxd/fmt/hmd/AnimationFlag.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_AnimationObject
#include <hxd/fmt/hmd/AnimationObject.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_Data
#include <hxd/fmt/hmd/Data.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_Geometry
#include <hxd/fmt/hmd/Geometry.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_GeometryBuffer
#include <hxd/fmt/hmd/GeometryBuffer.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_GeometryFormat
#include <hxd/fmt/hmd/GeometryFormat.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_Library
#include <hxd/fmt/hmd/Library.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_Material
#include <hxd/fmt/hmd/Material.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_Model
#include <hxd/fmt/hmd/Model.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_Position
#include <hxd/fmt/hmd/Position.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_Property
#include <hxd/fmt/hmd/Property.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_Skin
#include <hxd/fmt/hmd/Skin.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_SkinJoint
#include <hxd/fmt/hmd/SkinJoint.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd_SkinSplit
#include <hxd/fmt/hmd/SkinSplit.h>
#endif
#ifndef INCLUDED_hxd_fmt_hmd__Library_FormatMap
#include <hxd/fmt/hmd/_Library/FormatMap.h>
#endif
#ifndef INCLUDED_hxd_fs_FileEntry
#include <hxd/fs/FileEntry.h>
#endif
#ifndef INCLUDED_hxd_impl_AnyProps
#include <hxd/impl/AnyProps.h>
#endif
#ifndef INCLUDED_hxd_impl__Serializable_NoSerializeSupport
#include <hxd/impl/_Serializable/NoSerializeSupport.h>
#endif
#ifndef INCLUDED_hxd_res_Resource
#include <hxd/res/Resource.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9da5ee183a4044bd_32_new,"hxd.fmt.hmd.Library","new",0xd2dc74e3,"hxd.fmt.hmd.Library.new","hxd/fmt/hmd/Library.hx",32,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_40_getData,"hxd.fmt.hmd.Library","getData",0xf00ea7e3,"hxd.fmt.hmd.Library.getData","hxd/fmt/hmd/Library.hx",40,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_50_getDefaultFormat,"hxd.fmt.hmd.Library","getDefaultFormat",0x42ba91ff,"hxd.fmt.hmd.Library.getDefaultFormat","hxd/fmt/hmd/Library.hx",50,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_72_load,"hxd.fmt.hmd.Library","load",0xacbee843,"hxd.fmt.hmd.Library.load","hxd/fmt/hmd/Library.hx",72,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_260_makePrimitive,"hxd.fmt.hmd.Library","makePrimitive",0xdb10071c,"hxd.fmt.hmd.Library.makePrimitive","hxd/fmt/hmd/Library.hx",260,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_269_makeMaterial,"hxd.fmt.hmd.Library","makeMaterial",0xecdc23d2,"hxd.fmt.hmd.Library.makeMaterial","hxd/fmt/hmd/Library.hx",269,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_290_makeSkin,"hxd.fmt.hmd.Library","makeSkin",0x2b582c28,"hxd.fmt.hmd.Library.makeSkin","hxd/fmt/hmd/Library.hx",290,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_327_getModelProperty,"hxd.fmt.hmd.Library","getModelProperty",0x37aea845,"hxd.fmt.hmd.Library.getModelProperty","hxd/fmt/hmd/Library.hx",327,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_342_makeObject,"hxd.fmt.hmd.Library","makeObject",0x0b73952a,"hxd.fmt.hmd.Library.makeObject","hxd/fmt/hmd/Library.hx",342,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_344_makeObject,"hxd.fmt.hmd.Library","makeObject",0x0b73952a,"hxd.fmt.hmd.Library.makeObject","hxd/fmt/hmd/Library.hx",344,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_373_loadAnimation,"hxd.fmt.hmd.Library","loadAnimation",0x88a94641,"hxd.fmt.hmd.Library.loadAnimation","hxd/fmt/hmd/Library.hx",373,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_404_makeAnimation,"hxd.fmt.hmd.Library","makeAnimation",0xfeec6d79,"hxd.fmt.hmd.Library.makeAnimation","hxd/fmt/hmd/Library.hx",404,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_487_makeLinearAnimation,"hxd.fmt.hmd.Library","makeLinearAnimation",0x67abdc94,"hxd.fmt.hmd.Library.makeLinearAnimation","hxd/fmt/hmd/Library.hx",487,0x88e81730)
HX_LOCAL_STACK_FRAME(_hx_pos_9da5ee183a4044bd_577_loadSkin,"hxd.fmt.hmd.Library","loadSkin",0xa55a0860,"hxd.fmt.hmd.Library.loadSkin","hxd/fmt/hmd/Library.hx",577,0x88e81730)
namespace hxd{
namespace fmt{
namespace hmd{

void Library_obj::__construct( ::hxd::res::Resource res, ::hxd::fmt::hmd::Data header){
            	HX_GC_STACKFRAME(&_hx_pos_9da5ee183a4044bd_32_new)
HXLINE(  33)		this->resource = res;
HXLINE(  34)		this->header = header;
HXLINE(  35)		this->cachedPrimitives = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  36)		this->cachedAnimations =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  37)		this->cachedSkin =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}

Dynamic Library_obj::__CreateEmpty() { return new Library_obj; }

void *Library_obj::_hx_vtable = 0;

Dynamic Library_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Library_obj > _hx_result = new Library_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Library_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4e5a6875;
}

 ::haxe::io::Bytes Library_obj::getData(){
            	HX_STACKFRAME(&_hx_pos_9da5ee183a4044bd_40_getData)
HXLINE(  41)		 ::hxd::fs::FileEntry entry = this->resource->entry;
HXLINE(  42)		int b = entry->get_size();
HXDLIN(  42)		 ::haxe::io::Bytes b1 = ::haxe::io::Bytes_obj::alloc((b - this->header->dataPosition));
HXLINE(  43)		entry->open();
HXLINE(  44)		entry->skip(this->header->dataPosition);
HXLINE(  45)		entry->read(b1,0,b1->length);
HXLINE(  46)		entry->close();
HXLINE(  47)		return b1;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Library_obj,getData,return )

 ::Dynamic Library_obj::getDefaultFormat(int stride){
            	HX_GC_STACKFRAME(&_hx_pos_9da5ee183a4044bd_50_getDefaultFormat)
HXLINE(  51)		::Array< ::Dynamic> format = ::Array_obj< ::Dynamic>::__new(1)->init(0, ::hxd::fmt::hmd::GeometryFormat_obj::__alloc( HX_CTX ,HX_("position",a9,a0,fa,ca),3));
HXLINE(  54)		::Array< ::Dynamic> defs = ::Array_obj< ::Dynamic>::__new(1)->init(0,null());
HXLINE(  55)		if ((stride > 3)) {
HXLINE(  56)			format->push( ::hxd::fmt::hmd::GeometryFormat_obj::__alloc( HX_CTX ,HX_("normal",27,72,69,30),3));
HXLINE(  57)			defs->push(null());
            		}
HXLINE(  59)		if ((stride > 6)) {
HXLINE(  60)			format->push( ::hxd::fmt::hmd::GeometryFormat_obj::__alloc( HX_CTX ,HX_("uv",61,66,00,00),2));
HXLINE(  61)			defs->push(null());
            		}
HXLINE(  63)		if ((stride > 8)) {
HXLINE(  64)			format->push( ::hxd::fmt::hmd::GeometryFormat_obj::__alloc( HX_CTX ,HX_("color",63,71,5c,4a),3));
HXLINE(  65)			defs->push( ::h3d::Vector_obj::__alloc( HX_CTX ,1,1,1,null()));
            		}
HXLINE(  67)		if ((stride > 11)) {
HXLINE(  68)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Unsupported stride",44,00,3d,7d)));
            		}
HXLINE(  69)		return  ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("format",37,8f,8e,fd),format)
            			->setFixed(1,HX_("defs",0e,53,66,42),defs));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Library_obj,getDefaultFormat,return )

 ::Dynamic Library_obj::load(::Array< ::Dynamic> format,::Array< ::Dynamic> defaults,::hx::Null< int >  __o_modelIndex){
            		int modelIndex = __o_modelIndex.Default(-1);
            	HX_STACKFRAME(&_hx_pos_9da5ee183a4044bd_72_load)
HXLINE(  73)		Float vtmp_x = ((Float)0.);
HXDLIN(  73)		Float vtmp_y = ((Float)0.);
HXDLIN(  73)		Float vtmp_z = ((Float)0.);
HXDLIN(  73)		Float vtmp_w = ((Float)1.);
HXLINE(  74)		::Array< ::Dynamic> models;
HXDLIN(  74)		if ((modelIndex < 0)) {
HXLINE(  74)			models = this->header->models;
            		}
            		else {
HXLINE(  74)			models = ::Array_obj< ::Dynamic>::__new(1)->init(0,this->header->models->__get(modelIndex).StaticCast<  ::hxd::fmt::hmd::Model >());
            		}
HXLINE(  75)		int length = 0;
HXDLIN(  75)		::Array< Float > this1 = ::Array_obj< Float >::__new();
HXDLIN(  75)		if ((length > 0)) {
HXLINE(  75)			if ((length > this1->length)) {
HXLINE(  75)				this1[(length - 1)] = ((Float)0.);
            			}
            		}
HXDLIN(  75)		::Array< Float > outVertex = this1;
HXLINE(  76)		int length1 = 0;
HXDLIN(  76)		::Array< int > this2 = ::Array_obj< int >::__new();
HXDLIN(  76)		if ((length1 > 0)) {
HXLINE(  76)			if ((length1 > this2->length)) {
HXLINE(  76)				this2[(length1 - 1)] = 0;
            			}
            		}
HXDLIN(  76)		::Array< int > outIndex = this2;
HXLINE(  77)		int stride = 0;
HXLINE(  78)		int mid = -1;
HXLINE(  79)		{
HXLINE(  79)			int _g = 0;
HXDLIN(  79)			while((_g < format->length)){
HXLINE(  79)				 ::hxd::fmt::hmd::GeometryFormat f = format->__get(_g).StaticCast<  ::hxd::fmt::hmd::GeometryFormat >();
HXDLIN(  79)				_g = (_g + 1);
HXLINE(  80)				stride = (stride + (f->format & 7));
            			}
            		}
HXLINE(  81)		{
HXLINE(  81)			int _g1 = 0;
HXDLIN(  81)			while((_g1 < models->length)){
HXLINE(  81)				 ::hxd::fmt::hmd::Model m = models->__get(_g1).StaticCast<  ::hxd::fmt::hmd::Model >();
HXDLIN(  81)				_g1 = (_g1 + 1);
HXLINE(  82)				 ::hxd::fmt::hmd::Geometry geom = this->header->geometries->__get(m->geometry).StaticCast<  ::hxd::fmt::hmd::Geometry >();
HXLINE(  83)				if (::hx::IsNull( geom )) {
HXLINE(  83)					continue;
            				}
HXLINE(  84)				{
HXLINE(  84)					int _g = 0;
HXDLIN(  84)					::Array< int > _g2 = m->materials;
HXDLIN(  84)					while((_g < _g2->length)){
HXLINE(  84)						int mat = _g2->__get(_g);
HXDLIN(  84)						_g = (_g + 1);
HXLINE(  85)						if ((mid < 0)) {
HXLINE(  85)							mid = mat;
            						}
HXLINE(  86)						if ((mid != mat)) {
HXLINE(  86)							HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Models have several materials",e6,29,17,9b)));
            						}
            					}
            				}
HXLINE(  88)				 ::h3d::Matrix pos = m->position->toMatrix(null());
HXLINE(  89)				 ::hxd::fmt::hmd::GeometryBuffer data = this->getBuffers(geom,format,defaults,null());
HXLINE(  90)				int start = ::Std_obj::_hx_int((( (Float)(outVertex->length) ) / ( (Float)(stride) )));
HXLINE(  91)				{
HXLINE(  91)					int _g3 = 0;
HXDLIN(  91)					int _g4 = ::Std_obj::_hx_int((( (Float)(data->vertexes->length) ) / ( (Float)(stride) )));
HXDLIN(  91)					while((_g3 < _g4)){
HXLINE(  91)						_g3 = (_g3 + 1);
HXDLIN(  91)						int i = (_g3 - 1);
HXLINE(  92)						int p = (i * stride);
HXLINE(  93)						p = (p + 1);
HXDLIN(  93)						vtmp_x = ( (Float)(_hx_array_unsafe_get(data->vertexes,(p - 1))) );
HXLINE(  94)						p = (p + 1);
HXDLIN(  94)						vtmp_y = ( (Float)(_hx_array_unsafe_get(data->vertexes,(p - 1))) );
HXLINE(  95)						p = (p + 1);
HXDLIN(  95)						vtmp_z = ( (Float)(_hx_array_unsafe_get(data->vertexes,(p - 1))) );
HXLINE(  96)						{
HXLINE(  96)							Float px = ((((vtmp_x * pos->_11) + (vtmp_y * pos->_21)) + (vtmp_z * pos->_31)) + (vtmp_w * pos->_41));
HXDLIN(  96)							Float py = ((((vtmp_x * pos->_12) + (vtmp_y * pos->_22)) + (vtmp_z * pos->_32)) + (vtmp_w * pos->_42));
HXDLIN(  96)							Float pz = ((((vtmp_x * pos->_13) + (vtmp_y * pos->_23)) + (vtmp_z * pos->_33)) + (vtmp_w * pos->_43));
HXDLIN(  96)							vtmp_x = px;
HXDLIN(  96)							vtmp_y = py;
HXDLIN(  96)							vtmp_z = pz;
            						}
HXLINE(  97)						outVertex->push(vtmp_x);
HXLINE(  98)						outVertex->push(vtmp_y);
HXLINE(  99)						outVertex->push(vtmp_z);
HXLINE( 100)						{
HXLINE( 100)							int _g = 0;
HXDLIN( 100)							int _g1 = (stride - 3);
HXDLIN( 100)							while((_g < _g1)){
HXLINE( 100)								_g = (_g + 1);
HXDLIN( 100)								int j = (_g - 1);
HXLINE( 101)								{
HXLINE( 101)									p = (p + 1);
HXDLIN( 101)									outVertex->push(_hx_array_unsafe_get(data->vertexes,(p - 1)));
            								}
            							}
            						}
            					}
            				}
HXLINE( 103)				{
HXLINE( 103)					int _g5 = 0;
HXDLIN( 103)					::Array< int > _g6 = data->indexes;
HXDLIN( 103)					while((_g5 < _g6->length)){
HXLINE( 103)						int idx = ( (int)(_hx_array_unsafe_get(_g6,_g5)) );
HXDLIN( 103)						_g5 = (_g5 + 1);
HXLINE( 104)						outIndex->push((idx + start));
            					}
            				}
            			}
            		}
HXLINE( 106)		return  ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("vertex",64,db,47,a1),outVertex)
            			->setFixed(1,HX_("index",12,9b,14,be),outIndex));
            	}


HX_DEFINE_DYNAMIC_FUNC3(Library_obj,load,return )

 ::hxd::fmt::hmd::GeometryBuffer Library_obj::getBuffers( ::hxd::fmt::hmd::Geometry geom,::Array< ::Dynamic> format,::Array< ::Dynamic> defaults, ::Dynamic material){
	HX_JUST_GC_STACKFRAME
	bool _hx_tmp;
	if (::hx::IsEq( material,0 )) {
		_hx_tmp = (geom->indexCounts->length == 1);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		material = null();
	}
	 ::hxd::fmt::hmd::_Library::FormatMap map = null();
	int stride = 0;
	{
		int _g = 0;
		int _g1 = format->length;
		while((_g < _g1)){
			_g = (_g + 1);
			int i = (_g - 1);
			int i1 = ((format->length - 1) - i);
			 ::hxd::fmt::hmd::GeometryFormat f = format->__get(i1).StaticCast<  ::hxd::fmt::hmd::GeometryFormat >();
			int size = (f->format & 7);
			int offset = 0;
			bool found = false;
			{
				int _g1 = 0;
				::Array< ::Dynamic> _g2 = geom->vertexFormat;
				while((_g1 < _g2->length)){
					 ::hxd::fmt::hmd::GeometryFormat f2 = _g2->__get(_g1).StaticCast<  ::hxd::fmt::hmd::GeometryFormat >();
					_g1 = (_g1 + 1);
					if ((f2->name == f->name)) {
						if (((f2->format & 7) < size)) {
							HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((((((HX_("Requested ",12,5b,c6,f7) + f->name) + HX_(" data has only ",98,66,ad,cb)) + (f2->format & 7)) + HX_(" regs instead of ",aa,db,ff,bc)) + size)));
						}
						found = true;
						goto _hx_goto_11;
					}
					offset = (offset + (f2->format & 7));
				}
				_hx_goto_11:;
			}
			if (found) {
				map =  ::hxd::fmt::hmd::_Library::FormatMap_obj::__alloc( HX_CTX ,size,offset,null(),map);
			}
			else {
				 ::h3d::Vector def;
				if (::hx::IsNull( defaults )) {
					def = null();
				}
				else {
					def = defaults->__get(i1).StaticCast<  ::h3d::Vector >();
				}
				if (::hx::IsNull( def )) {
					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Missing required ",87,98,d9,99) + f->name)));
				}
				map =  ::hxd::fmt::hmd::_Library::FormatMap_obj::__alloc( HX_CTX ,size,0,def,map);
			}
			stride = (stride + size);
		}
	}
	int vsize = ((geom->vertexCount * geom->vertexStride) * 4);
	 ::haxe::io::Bytes vbuf = ::haxe::io::Bytes_obj::alloc(vsize);
	 ::hxd::fs::FileEntry entry = this->resource->entry;
	entry->open();
	entry->skip((this->header->dataPosition + geom->vertexPosition));
	entry->read(vbuf,0,vsize);
	entry->skip((geom->indexPosition - (geom->vertexPosition + vsize)));
	bool isSmall = (geom->vertexCount <= 65536);
	int imult;
	if (isSmall) {
		imult = 2;
	}
	else {
		imult = 4;
	}
	int isize;
	if (::hx::IsNull( material )) {
		isize = (geom->get_indexCount() * imult);
	}
	else {
		int ipos = 0;
		{
			int _g = 0;
			 ::Dynamic _g1 = material;
			while(::hx::IsLess( _g,_g1 )){
				_g = (_g + 1);
				int i = (_g - 1);
				ipos = (ipos + geom->indexCounts->__get(i));
			}
		}
		entry->skip((ipos * imult));
		isize = (geom->indexCounts->__get(( (int)(material) )) * imult);
	}
	 ::haxe::io::Bytes ibuf = ::haxe::io::Bytes_obj::alloc(isize);
	entry->read(ibuf,0,isize);
	 ::hxd::fmt::hmd::GeometryBuffer buf =  ::hxd::fmt::hmd::GeometryBuffer_obj::__alloc( HX_CTX );
	if (::hx::IsNull( material )) {
		::Array< Float > this1 = ::Array_obj< Float >::__new((stride * geom->vertexCount));
		buf->vertexes = this1;
		::Array< int > this2 = ::Array_obj< int >::__new(geom->get_indexCount());
		buf->indexes = this2;
		int w = 0;
		{
			int _g = 0;
			int _g1 = geom->vertexCount;
			while((_g < _g1)){
				_g = (_g + 1);
				int vid = (_g - 1);
				 ::hxd::fmt::hmd::_Library::FormatMap m = map;
				while(::hx::IsNotNull( m )){
					if (::hx::IsNull( m->def )) {
						int r = (vid * geom->vertexStride);
						{
							int _g = 0;
							int _g1 = m->size;
							while((_g < _g1)){
								_g = (_g + 1);
								int i = (_g - 1);
								{
									::Array< Float > this1 = buf->vertexes;
									w = (w + 1);
									int pos = (((r + m->offset) + i) << 2);
									bool _hx_tmp;
									if ((pos >= 0)) {
										_hx_tmp = ((pos + 4) > vbuf->length);
									}
									else {
										_hx_tmp = true;
									}
									if (_hx_tmp) {
										HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
									}
									Float val =  ::__hxcpp_memory_get_float(vbuf->b,pos);
									this1->__unsafe_set((w - 1),val);
								}
							}
						}
					}
					else {
						switch((int)(m->size)){
							case (int)1: {
								w = (w + 1);
								buf->vertexes->__unsafe_set((w - 1),m->def->x);
							}
							break;
							case (int)2: {
								{
									w = (w + 1);
									buf->vertexes->__unsafe_set((w - 1),m->def->x);
								}
								{
									w = (w + 1);
									buf->vertexes->__unsafe_set((w - 1),m->def->y);
								}
							}
							break;
							case (int)3: {
								{
									w = (w + 1);
									buf->vertexes->__unsafe_set((w - 1),m->def->x);
								}
								{
									w = (w + 1);
									buf->vertexes->__unsafe_set((w - 1),m->def->y);
								}
								{
									w = (w + 1);
									buf->vertexes->__unsafe_set((w - 1),m->def->z);
								}
							}
							break;
							default:{
								{
									w = (w + 1);
									buf->vertexes->__unsafe_set((w - 1),m->def->x);
								}
								{
									w = (w + 1);
									buf->vertexes->__unsafe_set((w - 1),m->def->y);
								}
								{
									w = (w + 1);
									buf->vertexes->__unsafe_set((w - 1),m->def->z);
								}
								{
									w = (w + 1);
									buf->vertexes->__unsafe_set((w - 1),m->def->w);
								}
							}
						}
					}
					m = m->next;
				}
			}
		}
		if (isSmall) {
			int r = 0;
			{
				int _g = 0;
				int _g1 = buf->indexes->length;
				while((_g < _g1)){
					_g = (_g + 1);
					int i = (_g - 1);
					{
						r = (r + 1);
						int val = ( (int)(ibuf->b->__get((r - 1))) );
						r = (r + 1);
						buf->indexes->__unsafe_set(i,(val | (( (int)(ibuf->b->__get((r - 1))) ) << 8)));
					}
				}
			}
		}
		else {
			int _g = 0;
			int _g1 = buf->indexes->length;
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				{
					int pos = (i << 2);
					buf->indexes->__unsafe_set(i,(((( (int)(ibuf->b->__get(pos)) ) | (( (int)(ibuf->b->__get((pos + 1))) ) << 8)) | (( (int)(ibuf->b->__get((pos + 2))) ) << 16)) | (( (int)(ibuf->b->__get((pos + 3))) ) << 24)));
				}
			}
		}
	}
	else {
		int icount = geom->indexCounts->__get(( (int)(material) ));
		::Array< int > this1 = ::Array_obj< int >::__new(geom->vertexCount);
		::Array< int > vmap = this1;
		int length = 0;
		::Array< Float > this2 = ::Array_obj< Float >::__new();
		if ((length > 0)) {
			if ((length > this2->length)) {
				this2[(length - 1)] = ((Float)0.);
			}
		}
		::Array< Float > vertexes = this2;
		::Array< int > this3 = ::Array_obj< int >::__new(icount);
		buf->indexes = this3;
		int r = 0;
		int vcount = 0;
		{
			int _g = 0;
			int _g1 = buf->indexes->length;
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				int vid;
				if (isSmall) {
					r = (r + 1);
					int vid1 = ( (int)(ibuf->b->__get((r - 1))) );
					r = (r + 1);
					vid = (vid1 | (( (int)(ibuf->b->__get((r - 1))) ) << 8));
				}
				else {
					int pos = (i << 2);
					vid = (((( (int)(ibuf->b->__get(pos)) ) | (( (int)(ibuf->b->__get((pos + 1))) ) << 8)) | (( (int)(ibuf->b->__get((pos + 2))) ) << 16)) | (( (int)(ibuf->b->__get((pos + 3))) ) << 24));
				}
				int rid = ( (int)(_hx_array_unsafe_get(vmap,vid)) );
				if ((rid == 0)) {
					vcount = (vcount + 1);
					rid = vcount;
					vmap->__unsafe_set(vid,rid);
					 ::hxd::fmt::hmd::_Library::FormatMap m = map;
					while(::hx::IsNotNull( m )){
						if (::hx::IsNull( m->def )) {
							int r = (vid * geom->vertexStride);
							{
								int _g = 0;
								int _g1 = m->size;
								while((_g < _g1)){
									_g = (_g + 1);
									int i = (_g - 1);
									{
										int pos = (((r + m->offset) + i) << 2);
										bool _hx_tmp;
										if ((pos >= 0)) {
											_hx_tmp = ((pos + 4) > vbuf->length);
										}
										else {
											_hx_tmp = true;
										}
										if (_hx_tmp) {
											HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
										}
										vertexes->push( ::__hxcpp_memory_get_float(vbuf->b,pos));
									}
								}
							}
						}
						else {
							switch((int)(m->size)){
								case (int)1: {
									vertexes->push(m->def->x);
								}
								break;
								case (int)2: {
									vertexes->push(m->def->x);
									vertexes->push(m->def->y);
								}
								break;
								case (int)3: {
									vertexes->push(m->def->x);
									vertexes->push(m->def->y);
									vertexes->push(m->def->z);
								}
								break;
								default:{
									vertexes->push(m->def->x);
									vertexes->push(m->def->y);
									vertexes->push(m->def->z);
									vertexes->push(m->def->w);
								}
							}
						}
						m = m->next;
					}
				}
				buf->indexes->__unsafe_set(i,(rid - 1));
			}
		}
		buf->vertexes = vertexes;
	}
	entry->close();
	return buf;
}


HX_DEFINE_DYNAMIC_FUNC4(Library_obj,getBuffers,return )

 ::h3d::prim::HMDModel Library_obj::makePrimitive(int id){
            	HX_GC_STACKFRAME(&_hx_pos_9da5ee183a4044bd_260_makePrimitive)
HXLINE( 261)		 ::h3d::prim::HMDModel p = this->cachedPrimitives->__get(id).StaticCast<  ::h3d::prim::HMDModel >();
HXLINE( 262)		if (::hx::IsNotNull( p )) {
HXLINE( 262)			return p;
            		}
HXLINE( 263)		p =  ::h3d::prim::HMDModel_obj::__alloc( HX_CTX ,this->header->geometries->__get(id).StaticCast<  ::hxd::fmt::hmd::Geometry >(),this->header->dataPosition,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 264)		p->incref();
HXLINE( 265)		this->cachedPrimitives[id] = p;
HXLINE( 266)		return p;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Library_obj,makePrimitive,return )

 ::h3d::mat::Material Library_obj::makeMaterial( ::hxd::fmt::hmd::Model model,int mid, ::Dynamic loadTexture){
            	HX_STACKFRAME(&_hx_pos_9da5ee183a4044bd_269_makeMaterial)
HXLINE( 270)		 ::hxd::fmt::hmd::Material m = this->header->materials->__get(mid).StaticCast<  ::hxd::fmt::hmd::Material >();
HXLINE( 271)		 ::h3d::mat::Material mat = ::h3d::mat::MaterialSetup_obj::current->createMaterial();
HXLINE( 272)		mat->name = m->name;
HXLINE( 273)		if (::hx::IsNotNull( m->diffuseTexture )) {
HXLINE( 274)			mat->set_texture(( ( ::h3d::mat::Texture)(loadTexture(m->diffuseTexture)) ));
HXLINE( 275)			if (::hx::IsNull( mat->get_texture() )) {
HXLINE( 275)				mat->set_texture(::h3d::mat::Texture_obj::fromColor(16711935,null()));
            			}
            		}
HXLINE( 277)		if (::hx::IsNotNull( m->specularTexture )) {
HXLINE( 278)			mat->set_specularTexture(( ( ::h3d::mat::Texture)(loadTexture(m->specularTexture)) ));
            		}
HXLINE( 279)		if (::hx::IsNotNull( m->normalMap )) {
HXLINE( 280)			mat->set_normalMap(( ( ::h3d::mat::Texture)(loadTexture(m->normalMap)) ));
            		}
HXLINE( 281)		mat->set_blendMode(m->blendMode);
HXLINE( 282)		mat->model = this->resource;
HXLINE( 283)		 ::Dynamic props = ::h3d::mat::MaterialSetup_obj::current->loadMaterialProps(mat);
HXLINE( 284)		if (::hx::IsNull( props )) {
HXLINE( 284)			props = mat->getDefaultModelProps();
            		}
HXLINE( 285)		mat->set_props(props);
HXLINE( 286)		return mat;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Library_obj,makeMaterial,return )

 ::h3d::anim::Skin Library_obj::makeSkin( ::hxd::fmt::hmd::Skin skin){
            	HX_GC_STACKFRAME(&_hx_pos_9da5ee183a4044bd_290_makeSkin)
HXLINE( 291)		 ::h3d::anim::Skin s = ( ( ::h3d::anim::Skin)(this->cachedSkin->get(skin->name)) );
HXLINE( 292)		if (::hx::IsNotNull( s )) {
HXLINE( 293)			return s;
            		}
HXLINE( 294)		s =  ::h3d::anim::Skin_obj::__alloc( HX_CTX ,skin->name,0,3);
HXLINE( 295)		s->namedJoints =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 296)		s->allJoints = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 297)		s->boundJoints = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 298)		s->rootJoints = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 299)		{
HXLINE( 299)			int _g = 0;
HXDLIN( 299)			::Array< ::Dynamic> _g1 = skin->joints;
HXDLIN( 299)			while((_g < _g1->length)){
HXLINE( 299)				 ::hxd::fmt::hmd::SkinJoint joint = _g1->__get(_g).StaticCast<  ::hxd::fmt::hmd::SkinJoint >();
HXDLIN( 299)				_g = (_g + 1);
HXLINE( 300)				 ::h3d::anim::Joint j =  ::h3d::anim::Joint_obj::__alloc( HX_CTX );
HXLINE( 301)				j->name = joint->name;
HXLINE( 302)				j->index = s->allJoints->length;
HXLINE( 303)				j->defMat = joint->position->toMatrix(null());
HXLINE( 304)				if ((joint->bind >= 0)) {
HXLINE( 305)					j->bindIndex = joint->bind;
HXLINE( 306)					j->transPos = joint->transpos->toMatrix(true);
HXLINE( 307)					s->boundJoints[j->bindIndex] = j;
            				}
HXLINE( 309)				if ((joint->parent >= 0)) {
HXLINE( 310)					 ::h3d::anim::Joint p = s->allJoints->__get(joint->parent).StaticCast<  ::h3d::anim::Joint >();
HXLINE( 311)					p->subs->push(j);
HXLINE( 312)					j->parent = p;
            				}
            				else {
HXLINE( 314)					s->rootJoints->push(j);
            				}
HXLINE( 315)				s->allJoints->push(j);
HXLINE( 316)				s->namedJoints->set(j->name,j);
            			}
            		}
HXLINE( 318)		if (::hx::IsNotNull( skin->split )) {
HXLINE( 319)			s->splitJoints = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 320)			{
HXLINE( 320)				int _g = 0;
HXDLIN( 320)				::Array< ::Dynamic> _g1 = skin->split;
HXDLIN( 320)				while((_g < _g1->length)){
HXLINE( 320)					 ::hxd::fmt::hmd::SkinSplit ss = _g1->__get(_g).StaticCast<  ::hxd::fmt::hmd::SkinSplit >();
HXDLIN( 320)					_g = (_g + 1);
HXLINE( 321)					::Array< ::Dynamic> s1 = s->splitJoints;
HXDLIN( 321)					int ss1 = ss->materialIndex;
HXDLIN( 321)					::Array< ::Dynamic> _g2 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 321)					{
HXLINE( 321)						int _g3 = 0;
HXDLIN( 321)						::Array< int > _g4 = ss->joints;
HXDLIN( 321)						while((_g3 < _g4->length)){
HXLINE( 321)							int j = _g4->__get(_g3);
HXDLIN( 321)							_g3 = (_g3 + 1);
HXDLIN( 321)							_g2->push(s->allJoints->__get(j).StaticCast<  ::h3d::anim::Joint >());
            						}
            					}
HXDLIN( 321)					s1->push( ::Dynamic(::hx::Anon_obj::Create(2)
            						->setFixed(0,HX_("joints",e9,e7,09,91),_g2)
            						->setFixed(1,HX_("material",a7,5c,a5,f0),ss1)));
            				}
            			}
            		}
HXLINE( 323)		this->cachedSkin->set(skin->name,s);
HXLINE( 324)		return s;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Library_obj,makeSkin,return )

 ::Dynamic Library_obj::getModelProperty(::String objName, ::hxd::fmt::hmd::Property p, ::Dynamic def){
            	HX_STACKFRAME(&_hx_pos_9da5ee183a4044bd_327_getModelProperty)
HXLINE( 328)		{
HXLINE( 328)			int _g = 0;
HXDLIN( 328)			::Array< ::Dynamic> _g1 = this->header->models;
HXDLIN( 328)			while((_g < _g1->length)){
HXLINE( 328)				 ::hxd::fmt::hmd::Model m = _g1->__get(_g).StaticCast<  ::hxd::fmt::hmd::Model >();
HXDLIN( 328)				_g = (_g + 1);
HXLINE( 329)				if ((m->name == objName)) {
HXLINE( 330)					if (::hx::IsNotNull( m->props )) {
HXLINE( 331)						int _g = 0;
HXDLIN( 331)						::Array< ::Dynamic> _g1 = m->props;
HXDLIN( 331)						while((_g < _g1->length)){
HXLINE( 331)							 ::hxd::fmt::hmd::Property pr = _g1->__get(_g).StaticCast<  ::hxd::fmt::hmd::Property >();
HXDLIN( 331)							_g = (_g + 1);
HXLINE( 332)							int _hx_tmp = _hx_getEnumValueIndex(pr);
HXDLIN( 332)							if ((_hx_tmp == _hx_getEnumValueIndex(p))) {
HXLINE( 333)								return ::Type_obj::enumParameters(pr)->__get(0);
            							}
            						}
            					}
HXLINE( 334)					return def;
            				}
            			}
            		}
HXLINE( 336)		if (::hx::IsNull( def )) {
HXLINE( 337)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(((HX_("Model ",77,84,5b,f5) + objName) + HX_(" not found",55,f3,a5,21))));
            		}
HXLINE( 338)		return def;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Library_obj,getModelProperty,return )

 ::h3d::scene::Object Library_obj::makeObject( ::Dynamic loadTexture){
            	HX_GC_STACKFRAME(&_hx_pos_9da5ee183a4044bd_342_makeObject)
HXLINE( 343)		if (::hx::IsNull( loadTexture )) {
            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            			 ::h3d::mat::Texture _hx_run(::String _){
            				HX_STACKFRAME(&_hx_pos_9da5ee183a4044bd_344_makeObject)
HXLINE( 344)				return ::h3d::mat::Texture_obj::fromColor(16711935,null());
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE( 344)			loadTexture =  ::Dynamic(new _hx_Closure_0());
            		}
HXLINE( 345)		if ((this->header->models->length == 0)) {
HXLINE( 346)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("This file does not contain any model",b7,36,f0,78)));
            		}
HXLINE( 347)		::Array< ::Dynamic> objs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 348)		{
HXLINE( 348)			int _g = 0;
HXDLIN( 348)			::Array< ::Dynamic> _g1 = this->header->models;
HXDLIN( 348)			while((_g < _g1->length)){
HXLINE( 348)				 ::hxd::fmt::hmd::Model m = _g1->__get(_g).StaticCast<  ::hxd::fmt::hmd::Model >();
HXDLIN( 348)				_g = (_g + 1);
HXLINE( 349)				 ::h3d::scene::Object obj;
HXLINE( 350)				if ((m->geometry < 0)) {
HXLINE( 351)					obj =  ::h3d::scene::Object_obj::__alloc( HX_CTX ,null());
            				}
            				else {
HXLINE( 353)					 ::h3d::prim::HMDModel prim = this->makePrimitive(m->geometry);
HXLINE( 354)					if (::hx::IsNotNull( m->skin )) {
HXLINE( 355)						 ::h3d::anim::Skin skinData = this->makeSkin(m->skin);
HXLINE( 356)						skinData->primitive = prim;
HXLINE( 357)						::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 357)						{
HXLINE( 357)							int _g1 = 0;
HXDLIN( 357)							::Array< int > _g2 = m->materials;
HXDLIN( 357)							while((_g1 < _g2->length)){
HXLINE( 357)								int mat = _g2->__get(_g1);
HXDLIN( 357)								_g1 = (_g1 + 1);
HXDLIN( 357)								_g->push(this->makeMaterial(m,mat,loadTexture));
            							}
            						}
HXDLIN( 357)						obj =  ::h3d::scene::Skin_obj::__alloc( HX_CTX ,skinData,_g,null());
            					}
            					else {
HXLINE( 358)						if ((m->materials->length == 1)) {
HXLINE( 359)							obj =  ::h3d::scene::Mesh_obj::__alloc( HX_CTX ,prim,this->makeMaterial(m,m->materials->__get(0),loadTexture),null());
            						}
            						else {
HXLINE( 361)							::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 361)							{
HXLINE( 361)								int _g1 = 0;
HXDLIN( 361)								::Array< int > _g2 = m->materials;
HXDLIN( 361)								while((_g1 < _g2->length)){
HXLINE( 361)									int mat = _g2->__get(_g1);
HXDLIN( 361)									_g1 = (_g1 + 1);
HXDLIN( 361)									_g->push(this->makeMaterial(m,mat,loadTexture));
            								}
            							}
HXDLIN( 361)							obj =  ::h3d::scene::MultiMaterial_obj::__alloc( HX_CTX ,prim,_g,null());
            						}
            					}
            				}
HXLINE( 363)				obj->name = m->name;
HXLINE( 364)				{
HXLINE( 364)					 ::h3d::Matrix v = m->position->toMatrix(null());
HXDLIN( 364)					obj->defaultTransform = v;
HXDLIN( 364)					{
HXLINE( 364)						int f = 1;
HXDLIN( 364)						bool b = true;
HXDLIN( 364)						if (b) {
HXLINE( 364)							 ::h3d::scene::Object obj1 = obj;
HXDLIN( 364)							obj1->flags = (obj1->flags | f);
            						}
            						else {
HXLINE( 364)							 ::h3d::scene::Object obj1 = obj;
HXDLIN( 364)							obj1->flags = (obj1->flags & ~(f));
            						}
            					}
            				}
HXLINE( 365)				objs->push(obj);
HXLINE( 366)				 ::h3d::scene::Object p = objs->__get(m->parent).StaticCast<  ::h3d::scene::Object >();
HXLINE( 367)				if (::hx::IsNotNull( p )) {
HXLINE( 367)					p->addChild(obj);
            				}
            			}
            		}
HXLINE( 369)		return objs->__get(0).StaticCast<  ::h3d::scene::Object >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Library_obj,makeObject,return )

 ::h3d::anim::Animation Library_obj::loadAnimation(::String name){
            	HX_STACKFRAME(&_hx_pos_9da5ee183a4044bd_373_loadAnimation)
HXLINE( 375)		::String a;
HXDLIN( 375)		if (::hx::IsNull( name )) {
HXLINE( 375)			a = HX_("",00,00,00,00);
            		}
            		else {
HXLINE( 375)			a = name;
            		}
HXDLIN( 375)		 ::h3d::anim::Animation a1 = ( ( ::h3d::anim::Animation)(this->cachedAnimations->get(a)) );
HXLINE( 376)		if (::hx::IsNotNull( a1 )) {
HXLINE( 377)			return a1;
            		}
HXLINE( 379)		 ::hxd::fmt::hmd::Animation a2 = null();
HXLINE( 380)		if (::hx::IsNull( name )) {
HXLINE( 381)			if ((this->header->animations->length == 0)) {
HXLINE( 382)				return null();
            			}
HXLINE( 383)			a2 = this->header->animations->__get(0).StaticCast<  ::hxd::fmt::hmd::Animation >();
            		}
            		else {
HXLINE( 385)			{
HXLINE( 385)				int _g = 0;
HXDLIN( 385)				::Array< ::Dynamic> _g1 = this->header->animations;
HXDLIN( 385)				while((_g < _g1->length)){
HXLINE( 385)					 ::hxd::fmt::hmd::Animation a21 = _g1->__get(_g).StaticCast<  ::hxd::fmt::hmd::Animation >();
HXDLIN( 385)					_g = (_g + 1);
HXLINE( 386)					if ((a21->name == name)) {
HXLINE( 387)						a2 = a21;
HXLINE( 388)						goto _hx_goto_35;
            					}
            				}
            				_hx_goto_35:;
            			}
HXLINE( 390)			if (::hx::IsNull( a2 )) {
HXLINE( 391)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(((HX_("Animation ",bc,38,cd,79) + name) + HX_(" not found !",96,4e,89,4d))));
            			}
            		}
HXLINE( 394)		 ::h3d::anim::Animation l;
HXDLIN( 394)		if ((this->header->version <= 2)) {
HXLINE( 394)			l = this->makeLinearAnimation(a2);
            		}
            		else {
HXLINE( 394)			l = this->makeAnimation(a2);
            		}
HXLINE( 395)		l->speed = a2->speed;
HXLINE( 396)		l->loop = a2->loop;
HXLINE( 397)		if (::hx::IsNotNull( a2->events )) {
HXLINE( 397)			l->setEvents(a2->events);
            		}
HXLINE( 398)		l->resourcePath = this->resource->entry->get_path();
HXLINE( 399)		this->cachedAnimations->set(a2->name,l);
HXLINE( 400)		if (::hx::IsNull( name )) {
HXLINE( 400)			this->cachedAnimations->set(HX_("",00,00,00,00),l);
            		}
HXLINE( 401)		return l;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Library_obj,loadAnimation,return )

 ::h3d::anim::BufferAnimation Library_obj::makeAnimation( ::hxd::fmt::hmd::Animation a){
            	HX_GC_STACKFRAME(&_hx_pos_9da5ee183a4044bd_404_makeAnimation)
HXLINE( 405)		 ::h3d::anim::BufferAnimation b =  ::h3d::anim::BufferAnimation_obj::__alloc( HX_CTX ,a->name,a->frames,a->sampling);
HXLINE( 407)		int stride = 0;
HXLINE( 408)		::Array< ::Dynamic> singleFrames = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 409)		::Array< ::Dynamic> otherFrames = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 410)		{
HXLINE( 410)			int _g = 0;
HXDLIN( 410)			::Array< ::Dynamic> _g1 = a->objects;
HXDLIN( 410)			while((_g < _g1->length)){
HXLINE( 410)				 ::hxd::fmt::hmd::AnimationObject o = _g1->__get(_g).StaticCast<  ::hxd::fmt::hmd::AnimationObject >();
HXDLIN( 410)				_g = (_g + 1);
HXLINE( 411)				 ::h3d::anim::BufferObject c = b->addObject(o->name,0);
HXLINE( 412)				int sm = 1;
HXLINE( 413)				int this1 = o->flags;
HXDLIN( 413)				if (((this1 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::SingleFrame_dyn()))) != 0)) {
HXLINE( 414)					 ::h3d::anim::BufferObject c1 = c;
HXDLIN( 414)					int c2 = c1->layout;
HXDLIN( 414)					c1->layout = (c2 | (1 << _hx_getEnumValueIndex(::h3d::anim::DataLayout_obj::SingleFrame_dyn())));
HXLINE( 415)					singleFrames->push(c);
HXLINE( 416)					sm = 0;
            				}
            				else {
HXLINE( 418)					otherFrames->push(c);
            				}
HXLINE( 419)				int this2 = o->flags;
HXDLIN( 419)				if (((this2 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasPosition_dyn()))) != 0)) {
HXLINE( 420)					 ::h3d::anim::BufferObject c1 = c;
HXDLIN( 420)					int c2 = c1->layout;
HXDLIN( 420)					c1->layout = (c2 | (1 << _hx_getEnumValueIndex(::h3d::anim::DataLayout_obj::Position_dyn())));
HXLINE( 421)					stride = (stride + (3 * sm));
            				}
HXLINE( 423)				int this3 = o->flags;
HXDLIN( 423)				if (((this3 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasRotation_dyn()))) != 0)) {
HXLINE( 424)					 ::h3d::anim::BufferObject c1 = c;
HXDLIN( 424)					int c2 = c1->layout;
HXDLIN( 424)					c1->layout = (c2 | (1 << _hx_getEnumValueIndex(::h3d::anim::DataLayout_obj::Rotation_dyn())));
HXLINE( 425)					stride = (stride + (3 * sm));
            				}
HXLINE( 427)				int this4 = o->flags;
HXDLIN( 427)				if (((this4 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasScale_dyn()))) != 0)) {
HXLINE( 428)					 ::h3d::anim::BufferObject c1 = c;
HXDLIN( 428)					int c2 = c1->layout;
HXDLIN( 428)					c1->layout = (c2 | (1 << _hx_getEnumValueIndex(::h3d::anim::DataLayout_obj::Scale_dyn())));
HXLINE( 429)					stride = (stride + (3 * sm));
            				}
HXLINE( 431)				int this5 = o->flags;
HXDLIN( 431)				if (((this5 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasUV_dyn()))) != 0)) {
HXLINE( 432)					 ::h3d::anim::BufferObject c1 = c;
HXDLIN( 432)					int c2 = c1->layout;
HXDLIN( 432)					c1->layout = (c2 | (1 << _hx_getEnumValueIndex(::h3d::anim::DataLayout_obj::UV_dyn())));
HXLINE( 433)					stride = (stride + (2 * sm));
            				}
HXLINE( 435)				int this6 = o->flags;
HXDLIN( 435)				if (((this6 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasAlpha_dyn()))) != 0)) {
HXLINE( 436)					 ::h3d::anim::BufferObject c1 = c;
HXDLIN( 436)					int c2 = c1->layout;
HXDLIN( 436)					c1->layout = (c2 | (1 << _hx_getEnumValueIndex(::h3d::anim::DataLayout_obj::Alpha_dyn())));
HXLINE( 437)					stride = (stride + sm);
            				}
HXLINE( 439)				int this7 = o->flags;
HXDLIN( 439)				if (((this7 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasProps_dyn()))) != 0)) {
HXLINE( 440)					int _g = 0;
HXDLIN( 440)					int _g1 = o->props->length;
HXDLIN( 440)					while((_g < _g1)){
HXLINE( 440)						_g = (_g + 1);
HXDLIN( 440)						int i = (_g - 1);
HXLINE( 441)						 ::h3d::anim::BufferObject c1 = c;
HXLINE( 442)						if ((i > 0)) {
HXLINE( 443)							c1 = b->addObject(o->name,0);
HXLINE( 444)							if ((sm == 0)) {
HXLINE( 444)								singleFrames->push(c1);
            							}
            							else {
HXLINE( 444)								otherFrames->push(c1);
            							}
            						}
HXLINE( 446)						 ::h3d::anim::BufferObject c2 = c1;
HXDLIN( 446)						int c3 = c2->layout;
HXDLIN( 446)						c2->layout = (c3 | (1 << _hx_getEnumValueIndex(::h3d::anim::DataLayout_obj::Property_dyn())));
HXLINE( 447)						c1->propName = o->props->__get(i);
HXLINE( 448)						stride = (stride + sm);
            					}
            				}
            			}
            		}
HXLINE( 454)		int pos = 0;
HXLINE( 455)		{
HXLINE( 455)			int _g2 = 0;
HXDLIN( 455)			while((_g2 < singleFrames->length)){
HXLINE( 455)				 ::h3d::anim::BufferObject b = singleFrames->__get(_g2).StaticCast<  ::h3d::anim::BufferObject >();
HXDLIN( 455)				_g2 = (_g2 + 1);
HXLINE( 456)				b->dataOffset = pos;
HXLINE( 457)				pos = (pos + b->getStride());
            			}
            		}
HXLINE( 459)		int singleStride = pos;
HXLINE( 460)		{
HXLINE( 460)			int _g3 = 0;
HXDLIN( 460)			while((_g3 < otherFrames->length)){
HXLINE( 460)				 ::h3d::anim::BufferObject b = otherFrames->__get(_g3).StaticCast<  ::h3d::anim::BufferObject >();
HXDLIN( 460)				_g3 = (_g3 + 1);
HXLINE( 461)				b->dataOffset = pos;
HXLINE( 462)				pos = (pos + b->getStride());
            			}
            		}
HXLINE( 465)		 ::hxd::fs::FileEntry entry = this->resource->entry;
HXLINE( 466)		entry->open();
HXLINE( 467)		entry->skip((this->header->dataPosition + a->dataPosition));
HXLINE( 468)		int count = ((stride * a->frames) + singleStride);
HXLINE( 469)		 ::haxe::io::Bytes data = ::haxe::io::Bytes_obj::alloc((count * 4));
HXLINE( 470)		entry->read(data,0,data->length);
HXLINE( 471)		entry->close();
HXLINE( 478)		::Array< Float > this1 = ::Array_obj< Float >::__new(count);
HXDLIN( 478)		::Array< Float > v = this1;
HXLINE( 479)		{
HXLINE( 479)			int _g4 = 0;
HXDLIN( 479)			int _g5 = count;
HXDLIN( 479)			while((_g4 < _g5)){
HXLINE( 479)				_g4 = (_g4 + 1);
HXDLIN( 479)				int i = (_g4 - 1);
HXLINE( 480)				{
HXLINE( 480)					int pos = (i << 2);
HXDLIN( 480)					bool _hx_tmp;
HXDLIN( 480)					if ((pos >= 0)) {
HXLINE( 480)						_hx_tmp = ((pos + 4) > data->length);
            					}
            					else {
HXLINE( 480)						_hx_tmp = true;
            					}
HXDLIN( 480)					if (_hx_tmp) {
HXLINE( 480)						HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            					}
HXDLIN( 480)					Float val =  ::__hxcpp_memory_get_float(data->b,pos);
HXDLIN( 480)					v->__unsafe_set(i,val);
            				}
            			}
            		}
HXLINE( 481)		b->setData(v,stride);
HXLINE( 484)		return b;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Library_obj,makeAnimation,return )

 ::h3d::anim::LinearAnimation Library_obj::makeLinearAnimation( ::hxd::fmt::hmd::Animation a){
            	HX_GC_STACKFRAME(&_hx_pos_9da5ee183a4044bd_487_makeLinearAnimation)
HXLINE( 488)		 ::h3d::anim::LinearAnimation l =  ::h3d::anim::LinearAnimation_obj::__alloc( HX_CTX ,a->name,a->frames,a->sampling);
HXLINE( 490)		 ::hxd::fs::FileEntry entry = this->resource->entry;
HXLINE( 491)		entry->open();
HXLINE( 492)		entry->skip((this->header->dataPosition + a->dataPosition));
HXLINE( 494)		{
HXLINE( 494)			int _g = 0;
HXDLIN( 494)			::Array< ::Dynamic> _g1 = a->objects;
HXDLIN( 494)			while((_g < _g1->length)){
HXLINE( 494)				 ::hxd::fmt::hmd::AnimationObject o = _g1->__get(_g).StaticCast<  ::hxd::fmt::hmd::AnimationObject >();
HXDLIN( 494)				_g = (_g + 1);
HXLINE( 495)				int this1 = o->flags;
HXDLIN( 495)				bool pos = ((this1 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasPosition_dyn()))) != 0);
HXDLIN( 495)				int this2 = o->flags;
HXDLIN( 495)				bool rot = ((this2 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasRotation_dyn()))) != 0);
HXDLIN( 495)				int this3 = o->flags;
HXDLIN( 495)				bool scale = ((this3 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasScale_dyn()))) != 0);
HXLINE( 496)				bool _hx_tmp;
HXDLIN( 496)				bool _hx_tmp1;
HXDLIN( 496)				if (!(pos)) {
HXLINE( 496)					_hx_tmp1 = rot;
            				}
            				else {
HXLINE( 496)					_hx_tmp1 = true;
            				}
HXDLIN( 496)				if (!(_hx_tmp1)) {
HXLINE( 496)					_hx_tmp = scale;
            				}
            				else {
HXLINE( 496)					_hx_tmp = true;
            				}
HXDLIN( 496)				if (_hx_tmp) {
HXLINE( 497)					int frameCount = a->frames;
HXLINE( 498)					int this1 = o->flags;
HXDLIN( 498)					if (((this1 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::SingleFrame_dyn()))) != 0)) {
HXLINE( 499)						frameCount = 1;
            					}
HXLINE( 500)					::Array< ::Dynamic> this2 = ::Array_obj< ::Dynamic>::__new(frameCount);
HXDLIN( 500)					::Array< ::Dynamic> fl = this2;
HXLINE( 501)					int size;
HXDLIN( 501)					if (pos) {
HXLINE( 501)						size = 3;
            					}
            					else {
HXLINE( 501)						size = 0;
            					}
HXDLIN( 501)					int size1;
HXDLIN( 501)					if (rot) {
HXLINE( 501)						size1 = 3;
            					}
            					else {
HXLINE( 501)						size1 = 0;
            					}
HXDLIN( 501)					int size2;
HXDLIN( 501)					if (scale) {
HXLINE( 501)						size2 = 3;
            					}
            					else {
HXLINE( 501)						size2 = 0;
            					}
HXDLIN( 501)					int size3 = ((((size + size1) + size2) * 4) * frameCount);
HXLINE( 502)					 ::haxe::io::Bytes data = ::haxe::io::Bytes_obj::alloc(size3);
HXLINE( 503)					entry->read(data,0,size3);
HXLINE( 504)					int p = 0;
HXLINE( 505)					{
HXLINE( 505)						int _g = 0;
HXDLIN( 505)						int _g1 = frameCount;
HXDLIN( 505)						while((_g < _g1)){
HXLINE( 505)							_g = (_g + 1);
HXDLIN( 505)							int i = (_g - 1);
HXLINE( 506)							 ::h3d::anim::LinearFrame f =  ::h3d::anim::LinearFrame_obj::__alloc( HX_CTX );
HXLINE( 507)							if (pos) {
HXLINE( 508)								bool _hx_tmp;
HXDLIN( 508)								if ((p >= 0)) {
HXLINE( 508)									_hx_tmp = ((p + 4) > data->length);
            								}
            								else {
HXLINE( 508)									_hx_tmp = true;
            								}
HXDLIN( 508)								if (_hx_tmp) {
HXLINE( 508)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 508)								f->tx =  ::__hxcpp_memory_get_float(data->b,p);
HXDLIN( 508)								p = (p + 4);
HXLINE( 509)								bool _hx_tmp1;
HXDLIN( 509)								if ((p >= 0)) {
HXLINE( 509)									_hx_tmp1 = ((p + 4) > data->length);
            								}
            								else {
HXLINE( 509)									_hx_tmp1 = true;
            								}
HXDLIN( 509)								if (_hx_tmp1) {
HXLINE( 509)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 509)								f->ty =  ::__hxcpp_memory_get_float(data->b,p);
HXDLIN( 509)								p = (p + 4);
HXLINE( 510)								bool _hx_tmp2;
HXDLIN( 510)								if ((p >= 0)) {
HXLINE( 510)									_hx_tmp2 = ((p + 4) > data->length);
            								}
            								else {
HXLINE( 510)									_hx_tmp2 = true;
            								}
HXDLIN( 510)								if (_hx_tmp2) {
HXLINE( 510)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 510)								f->tz =  ::__hxcpp_memory_get_float(data->b,p);
HXDLIN( 510)								p = (p + 4);
            							}
            							else {
HXLINE( 512)								f->tx = ( (Float)(0) );
HXLINE( 513)								f->ty = ( (Float)(0) );
HXLINE( 514)								f->tz = ( (Float)(0) );
            							}
HXLINE( 516)							if (rot) {
HXLINE( 517)								bool _hx_tmp;
HXDLIN( 517)								if ((p >= 0)) {
HXLINE( 517)									_hx_tmp = ((p + 4) > data->length);
            								}
            								else {
HXLINE( 517)									_hx_tmp = true;
            								}
HXDLIN( 517)								if (_hx_tmp) {
HXLINE( 517)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 517)								f->qx =  ::__hxcpp_memory_get_float(data->b,p);
HXDLIN( 517)								p = (p + 4);
HXLINE( 518)								bool _hx_tmp1;
HXDLIN( 518)								if ((p >= 0)) {
HXLINE( 518)									_hx_tmp1 = ((p + 4) > data->length);
            								}
            								else {
HXLINE( 518)									_hx_tmp1 = true;
            								}
HXDLIN( 518)								if (_hx_tmp1) {
HXLINE( 518)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 518)								f->qy =  ::__hxcpp_memory_get_float(data->b,p);
HXDLIN( 518)								p = (p + 4);
HXLINE( 519)								bool _hx_tmp2;
HXDLIN( 519)								if ((p >= 0)) {
HXLINE( 519)									_hx_tmp2 = ((p + 4) > data->length);
            								}
            								else {
HXLINE( 519)									_hx_tmp2 = true;
            								}
HXDLIN( 519)								if (_hx_tmp2) {
HXLINE( 519)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 519)								f->qz =  ::__hxcpp_memory_get_float(data->b,p);
HXDLIN( 519)								p = (p + 4);
HXLINE( 520)								Float qw = (( (Float)(1) ) - (((f->qx * f->qx) + (f->qy * f->qy)) + (f->qz * f->qz)));
HXLINE( 521)								Float _hx_tmp3;
HXDLIN( 521)								if ((qw < 0)) {
HXLINE( 521)									_hx_tmp3 = -(::Math_obj::sqrt(-(qw)));
            								}
            								else {
HXLINE( 521)									_hx_tmp3 = ::Math_obj::sqrt(qw);
            								}
HXDLIN( 521)								f->qw = _hx_tmp3;
            							}
            							else {
HXLINE( 523)								f->qx = ( (Float)(0) );
HXLINE( 524)								f->qy = ( (Float)(0) );
HXLINE( 525)								f->qz = ( (Float)(0) );
HXLINE( 526)								f->qw = ( (Float)(1) );
            							}
HXLINE( 528)							if (scale) {
HXLINE( 529)								bool _hx_tmp;
HXDLIN( 529)								if ((p >= 0)) {
HXLINE( 529)									_hx_tmp = ((p + 4) > data->length);
            								}
            								else {
HXLINE( 529)									_hx_tmp = true;
            								}
HXDLIN( 529)								if (_hx_tmp) {
HXLINE( 529)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 529)								f->sx =  ::__hxcpp_memory_get_float(data->b,p);
HXDLIN( 529)								p = (p + 4);
HXLINE( 530)								bool _hx_tmp1;
HXDLIN( 530)								if ((p >= 0)) {
HXLINE( 530)									_hx_tmp1 = ((p + 4) > data->length);
            								}
            								else {
HXLINE( 530)									_hx_tmp1 = true;
            								}
HXDLIN( 530)								if (_hx_tmp1) {
HXLINE( 530)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 530)								f->sy =  ::__hxcpp_memory_get_float(data->b,p);
HXDLIN( 530)								p = (p + 4);
HXLINE( 531)								bool _hx_tmp2;
HXDLIN( 531)								if ((p >= 0)) {
HXLINE( 531)									_hx_tmp2 = ((p + 4) > data->length);
            								}
            								else {
HXLINE( 531)									_hx_tmp2 = true;
            								}
HXDLIN( 531)								if (_hx_tmp2) {
HXLINE( 531)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 531)								f->sz =  ::__hxcpp_memory_get_float(data->b,p);
HXDLIN( 531)								p = (p + 4);
            							}
            							else {
HXLINE( 533)								f->sx = ( (Float)(1) );
HXLINE( 534)								f->sy = ( (Float)(1) );
HXLINE( 535)								f->sz = ( (Float)(1) );
            							}
HXLINE( 537)							fl->__unsafe_set(i,f);
            						}
            					}
HXLINE( 539)					l->addCurve(o->name,fl,true,rot,scale);
            				}
HXLINE( 541)				int this4 = o->flags;
HXDLIN( 541)				if (((this4 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasUV_dyn()))) != 0)) {
HXLINE( 542)					::Array< Float > this1 = ::Array_obj< Float >::__new((a->frames * 2));
HXDLIN( 542)					::Array< Float > fl = this1;
HXLINE( 543)					int size = (8 * a->frames);
HXLINE( 544)					 ::haxe::io::Bytes data = ::haxe::io::Bytes_obj::alloc(size);
HXLINE( 545)					entry->read(data,0,size);
HXLINE( 546)					{
HXLINE( 546)						int _g = 0;
HXDLIN( 546)						int _g1 = fl->length;
HXDLIN( 546)						while((_g < _g1)){
HXLINE( 546)							_g = (_g + 1);
HXDLIN( 546)							int i = (_g - 1);
HXLINE( 547)							{
HXLINE( 547)								int pos = (i * 4);
HXDLIN( 547)								bool _hx_tmp;
HXDLIN( 547)								if ((pos >= 0)) {
HXLINE( 547)									_hx_tmp = ((pos + 4) > data->length);
            								}
            								else {
HXLINE( 547)									_hx_tmp = true;
            								}
HXDLIN( 547)								if (_hx_tmp) {
HXLINE( 547)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 547)								Float val =  ::__hxcpp_memory_get_float(data->b,pos);
HXDLIN( 547)								fl->__unsafe_set(i,val);
            							}
            						}
            					}
HXLINE( 548)					l->addUVCurve(o->name,fl);
            				}
HXLINE( 550)				int this5 = o->flags;
HXDLIN( 550)				if (((this5 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasAlpha_dyn()))) != 0)) {
HXLINE( 551)					::Array< Float > this1 = ::Array_obj< Float >::__new(a->frames);
HXDLIN( 551)					::Array< Float > fl = this1;
HXLINE( 552)					int size = (4 * a->frames);
HXLINE( 553)					 ::haxe::io::Bytes data = ::haxe::io::Bytes_obj::alloc(size);
HXLINE( 554)					entry->read(data,0,size);
HXLINE( 555)					{
HXLINE( 555)						int _g = 0;
HXDLIN( 555)						int _g1 = fl->length;
HXDLIN( 555)						while((_g < _g1)){
HXLINE( 555)							_g = (_g + 1);
HXDLIN( 555)							int i = (_g - 1);
HXLINE( 556)							{
HXLINE( 556)								int pos = (i * 4);
HXDLIN( 556)								bool _hx_tmp;
HXDLIN( 556)								if ((pos >= 0)) {
HXLINE( 556)									_hx_tmp = ((pos + 4) > data->length);
            								}
            								else {
HXLINE( 556)									_hx_tmp = true;
            								}
HXDLIN( 556)								if (_hx_tmp) {
HXLINE( 556)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            								}
HXDLIN( 556)								Float val =  ::__hxcpp_memory_get_float(data->b,pos);
HXDLIN( 556)								fl->__unsafe_set(i,val);
            							}
            						}
            					}
HXLINE( 557)					l->addAlphaCurve(o->name,fl);
            				}
HXLINE( 559)				int this6 = o->flags;
HXDLIN( 559)				if (((this6 & (1 << _hx_getEnumValueIndex(::hxd::fmt::hmd::AnimationFlag_obj::HasProps_dyn()))) != 0)) {
HXLINE( 560)					int _g = 0;
HXDLIN( 560)					::Array< ::String > _g1 = o->props;
HXDLIN( 560)					while((_g < _g1->length)){
HXLINE( 560)						::String p = _g1->__get(_g);
HXDLIN( 560)						_g = (_g + 1);
HXLINE( 561)						::Array< Float > this1 = ::Array_obj< Float >::__new(a->frames);
HXDLIN( 561)						::Array< Float > fl = this1;
HXLINE( 562)						int size = (4 * a->frames);
HXLINE( 563)						 ::haxe::io::Bytes data = ::haxe::io::Bytes_obj::alloc(size);
HXLINE( 564)						entry->read(data,0,size);
HXLINE( 565)						{
HXLINE( 565)							int _g2 = 0;
HXDLIN( 565)							int _g3 = fl->length;
HXDLIN( 565)							while((_g2 < _g3)){
HXLINE( 565)								_g2 = (_g2 + 1);
HXDLIN( 565)								int i = (_g2 - 1);
HXLINE( 566)								{
HXLINE( 566)									int pos = (i * 4);
HXDLIN( 566)									bool _hx_tmp;
HXDLIN( 566)									if ((pos >= 0)) {
HXLINE( 566)										_hx_tmp = ((pos + 4) > data->length);
            									}
            									else {
HXLINE( 566)										_hx_tmp = true;
            									}
HXDLIN( 566)									if (_hx_tmp) {
HXLINE( 566)										HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(::haxe::io::Error_obj::OutsideBounds_dyn()));
            									}
HXDLIN( 566)									Float val =  ::__hxcpp_memory_get_float(data->b,pos);
HXDLIN( 566)									fl->__unsafe_set(i,val);
            								}
            							}
            						}
HXLINE( 567)						l->addPropCurve(o->name,p,fl);
            					}
            				}
            			}
            		}
HXLINE( 572)		entry->close();
HXLINE( 573)		return l;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Library_obj,makeLinearAnimation,return )

void Library_obj::loadSkin( ::hxd::fmt::hmd::Geometry geom, ::h3d::anim::Skin skin,::hx::Null< bool >  __o_optimize){
            		bool optimize = __o_optimize.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_9da5ee183a4044bd_577_loadSkin)
HXLINE( 578)		if (::hx::IsNotNull( skin->vertexWeights )) {
HXLINE( 579)			return;
            		}
HXLINE( 581)		if ((skin->bonesPerVertex != 3)) {
HXLINE( 582)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("assert",c6,46,03,4c)));
            		}
HXLINE( 584)		skin->vertexCount = geom->vertexCount;
HXLINE( 585)		 ::hxd::fmt::hmd::GeometryFormat data =  ::hxd::fmt::hmd::GeometryFormat_obj::__alloc( HX_CTX ,HX_("position",a9,a0,fa,ca),3);
HXDLIN( 585)		 ::hxd::fmt::hmd::GeometryFormat data1 =  ::hxd::fmt::hmd::GeometryFormat_obj::__alloc( HX_CTX ,HX_("weights",fb,d7,fc,6f),3);
HXDLIN( 585)		 ::hxd::fmt::hmd::GeometryBuffer data2 = this->getBuffers(geom,::Array_obj< ::Dynamic>::__new(3)->init(0,data)->init(1,data1)->init(2, ::hxd::fmt::hmd::GeometryFormat_obj::__alloc( HX_CTX ,HX_("indexes",00,5c,bf,e0),9)),null(),null());
HXLINE( 586)		::Array< Float > this1 = ::Array_obj< Float >::__new((skin->vertexCount * skin->bonesPerVertex));
HXDLIN( 586)		skin->vertexWeights = this1;
HXLINE( 587)		::Array< int > this2 = ::Array_obj< int >::__new((skin->vertexCount * skin->bonesPerVertex));
HXDLIN( 587)		skin->vertexJoints = this2;
HXLINE( 589)		{
HXLINE( 589)			int _g = 0;
HXDLIN( 589)			::Array< ::Dynamic> _g1 = skin->boundJoints;
HXDLIN( 589)			while((_g < _g1->length)){
HXLINE( 589)				 ::h3d::anim::Joint j = _g1->__get(_g).StaticCast<  ::h3d::anim::Joint >();
HXDLIN( 589)				_g = (_g + 1);
HXLINE( 590)				j->offsets =  ::h3d::col::Bounds_obj::__alloc( HX_CTX );
            			}
            		}
HXLINE( 592)		::Array< Float > vbuf = data2->vertexes;
HXLINE( 593)		int idx = 0;
HXLINE( 594)		Float bounds_xMin = ((Float)1e20);
HXDLIN( 594)		Float bounds_xMax = ((Float)-1e20);
HXDLIN( 594)		Float bounds_yMin = ((Float)1e20);
HXDLIN( 594)		Float bounds_yMax = ((Float)-1e20);
HXDLIN( 594)		Float bounds_zMin = ((Float)1e20);
HXDLIN( 594)		Float bounds_zMax = ((Float)-1e20);
HXLINE( 595)		Float out = ::Math_obj::NaN;
HXLINE( 596)		::Array< ::Dynamic> ranges;
HXLINE( 597)		if (::hx::IsNull( skin->splitJoints )) {
HXLINE( 598)			::Array< ::Dynamic> jointsByBind = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 599)			{
HXLINE( 599)				int _g = 0;
HXDLIN( 599)				::Array< ::Dynamic> _g1 = skin->boundJoints;
HXDLIN( 599)				while((_g < _g1->length)){
HXLINE( 599)					 ::h3d::anim::Joint j = _g1->__get(_g).StaticCast<  ::h3d::anim::Joint >();
HXDLIN( 599)					_g = (_g + 1);
HXLINE( 600)					jointsByBind[j->bindIndex] = j;
            				}
            			}
HXLINE( 601)			ranges = ::Array_obj< ::Dynamic>::__new(1)->init(0, ::Dynamic(::hx::Anon_obj::Create(4)
            				->setFixed(0,HX_("joints",e9,e7,09,91),jointsByBind)
            				->setFixed(1,HX_("index",12,9b,14,be),0)
            				->setFixed(2,HX_("pos",94,5d,55,00),0)
            				->setFixed(3,HX_("count",cf,44,63,4a),data2->indexes->length)));
            		}
            		else {
HXLINE( 603)			int idx = 0;
HXLINE( 604)			::Array< int > triPos = ::Array_obj< int >::__new(0);
HXDLIN( 604)			int pos = 0;
HXLINE( 605)			{
HXLINE( 605)				int _g = 0;
HXDLIN( 605)				::Array< int > _g1 = geom->indexCounts;
HXDLIN( 605)				while((_g < _g1->length)){
HXLINE( 605)					int n = _g1->__get(_g);
HXDLIN( 605)					_g = (_g + 1);
HXLINE( 606)					triPos->push(pos);
HXLINE( 607)					pos = (pos + n);
            				}
            			}
HXLINE( 609)			::Array< ::Dynamic> _g2 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 609)			int _g3 = 0;
HXDLIN( 609)			::Array< ::Dynamic> _g4 = skin->splitJoints;
HXDLIN( 609)			while((_g3 < _g4->length)){
HXLINE( 609)				 ::Dynamic j = _g4->__get(_g3);
HXDLIN( 609)				_g3 = (_g3 + 1);
HXLINE( 610)				int idx1 = idx;
HXLINE( 611)				int triPos1 = triPos->__get(idx);
HXLINE( 612)				idx = (idx + 1);
HXLINE( 609)				_g2->push( ::Dynamic(::hx::Anon_obj::Create(4)
            					->setFixed(0,HX_("joints",e9,e7,09,91), ::Dynamic(j->__Field(HX_("joints",e9,e7,09,91),::hx::paccDynamic)))
            					->setFixed(1,HX_("index",12,9b,14,be),idx1)
            					->setFixed(2,HX_("pos",94,5d,55,00),triPos1)
            					->setFixed(3,HX_("count",cf,44,63,4a),geom->indexCounts->__get((idx - 1)))));
            			}
HXDLIN( 609)			ranges = _g2;
            		}
HXLINE( 619)		{
HXLINE( 619)			int _g2 = 0;
HXDLIN( 619)			while((_g2 < ranges->length)){
HXLINE( 619)				 ::Dynamic r = ranges->__get(_g2);
HXDLIN( 619)				_g2 = (_g2 + 1);
HXLINE( 620)				{
HXLINE( 620)					int _g = ( (int)(r->__Field(HX_("pos",94,5d,55,00),::hx::paccDynamic)) );
HXDLIN( 620)					int _g1 = ( (int)((r->__Field(HX_("pos",94,5d,55,00),::hx::paccDynamic) + r->__Field(HX_("count",cf,44,63,4a),::hx::paccDynamic))) );
HXDLIN( 620)					while((_g < _g1)){
HXLINE( 620)						_g = (_g + 1);
HXDLIN( 620)						int idx = (_g - 1);
HXLINE( 621)						int vidx = ( (int)(_hx_array_unsafe_get(data2->indexes,idx)) );
HXLINE( 622)						int p = (vidx * 7);
HXLINE( 623)						Float x = ( (Float)(_hx_array_unsafe_get(vbuf,p)) );
HXLINE( 624)						if ((x != x)) {
HXLINE( 626)							continue;
            						}
HXLINE( 628)						{
HXLINE( 628)							p = (p + 1);
HXDLIN( 628)							vbuf->__unsafe_set((p - 1),out);
            						}
HXLINE( 629)						p = (p + 1);
HXDLIN( 629)						Float y = ( (Float)(_hx_array_unsafe_get(vbuf,(p - 1))) );
HXLINE( 630)						p = (p + 1);
HXDLIN( 630)						Float z = ( (Float)(_hx_array_unsafe_get(vbuf,(p - 1))) );
HXLINE( 631)						p = (p + 1);
HXDLIN( 631)						Float w1 = ( (Float)(_hx_array_unsafe_get(vbuf,(p - 1))) );
HXLINE( 632)						p = (p + 1);
HXDLIN( 632)						Float w2 = ( (Float)(_hx_array_unsafe_get(vbuf,(p - 1))) );
HXLINE( 633)						p = (p + 1);
HXDLIN( 633)						Float w3 = ( (Float)(_hx_array_unsafe_get(vbuf,(p - 1))) );
HXLINE( 635)						int vout = (vidx * 3);
HXLINE( 636)						skin->vertexWeights->__unsafe_set(vout,w1);
HXLINE( 637)						skin->vertexWeights->__unsafe_set((vout + 1),w2);
HXLINE( 638)						skin->vertexWeights->__unsafe_set((vout + 2),w3);
HXLINE( 640)						int w;
HXDLIN( 640)						if ((w1 == 0)) {
HXLINE( 640)							w = 1;
            						}
            						else {
HXLINE( 640)							w = 0;
            						}
HXDLIN( 640)						int w4;
HXDLIN( 640)						if ((w2 == 0)) {
HXLINE( 640)							w4 = 2;
            						}
            						else {
HXLINE( 640)							w4 = 0;
            						}
HXDLIN( 640)						int w5;
HXDLIN( 640)						if ((w3 == 0)) {
HXLINE( 640)							w5 = 4;
            						}
            						else {
HXLINE( 640)							w5 = 0;
            						}
HXDLIN( 640)						int w6 = ((w | w4) | w5);
HXLINE( 641)						p = (p + 1);
HXDLIN( 641)						int idx1 = ::haxe::io::FPHelper_obj::floatToI32(( (Float)(_hx_array_unsafe_get(vbuf,(p - 1))) ));
HXLINE( 642)						{
HXLINE( 642)							if ((x < bounds_xMin)) {
HXLINE( 642)								bounds_xMin = x;
            							}
HXDLIN( 642)							if ((x > bounds_xMax)) {
HXLINE( 642)								bounds_xMax = x;
            							}
HXDLIN( 642)							if ((y < bounds_yMin)) {
HXLINE( 642)								bounds_yMin = y;
            							}
HXDLIN( 642)							if ((y > bounds_yMax)) {
HXLINE( 642)								bounds_yMax = y;
            							}
HXDLIN( 642)							if ((z < bounds_zMin)) {
HXLINE( 642)								bounds_zMin = z;
            							}
HXDLIN( 642)							if ((z > bounds_zMax)) {
HXLINE( 642)								bounds_zMax = z;
            							}
            						}
HXLINE( 643)						{
HXLINE( 643)							int _g1 = 0;
HXDLIN( 643)							while((_g1 < 3)){
HXLINE( 643)								_g1 = (_g1 + 1);
HXDLIN( 643)								int i = (_g1 - 1);
HXLINE( 644)								if (((w6 & (1 << i)) != 0)) {
HXLINE( 645)									{
HXLINE( 645)										vout = (vout + 1);
HXDLIN( 645)										skin->vertexJoints->__unsafe_set((vout - 1),-1);
            									}
HXLINE( 646)									continue;
            								}
HXLINE( 648)								int idx = ((idx1 >> (i << 3)) & 255);
HXLINE( 649)								 ::h3d::anim::Joint j = Dynamic(  ::Dynamic(r->__Field(HX_("joints",e9,e7,09,91),::hx::paccDynamic))->__GetItem(idx)).StaticCast<  ::h3d::anim::Joint >();
HXLINE( 650)								{
HXLINE( 650)									 ::h3d::col::Bounds _this = j->offsets;
HXDLIN( 650)									if ((x < _this->xMin)) {
HXLINE( 650)										_this->xMin = x;
            									}
HXDLIN( 650)									if ((x > _this->xMax)) {
HXLINE( 650)										_this->xMax = x;
            									}
HXDLIN( 650)									if ((y < _this->yMin)) {
HXLINE( 650)										_this->yMin = y;
            									}
HXDLIN( 650)									if ((y > _this->yMax)) {
HXLINE( 650)										_this->yMax = y;
            									}
HXDLIN( 650)									if ((z < _this->zMin)) {
HXLINE( 650)										_this->zMin = z;
            									}
HXDLIN( 650)									if ((z > _this->zMax)) {
HXLINE( 650)										_this->zMax = z;
            									}
            								}
HXLINE( 651)								{
HXLINE( 651)									vout = (vout + 1);
HXDLIN( 651)									skin->vertexJoints->__unsafe_set((vout - 1),j->bindIndex);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 656)		if (optimize) {
HXLINE( 657)			int idx = (skin->allJoints->length - 1);
HXLINE( 658)			int optOut = 0;
HXLINE( 659)			Float refVolume = (((bounds_xMax - bounds_xMin) * (bounds_yMax - bounds_yMin)) * (bounds_zMax - bounds_zMin));
HXLINE( 660)			while((idx >= 0)){
HXLINE( 661)				idx = (idx - 1);
HXDLIN( 661)				 ::h3d::anim::Joint j = skin->allJoints->__get((idx + 1)).StaticCast<  ::h3d::anim::Joint >();
HXLINE( 662)				bool _hx_tmp;
HXDLIN( 662)				bool _hx_tmp1;
HXDLIN( 662)				if (::hx::IsNotNull( j->offsets )) {
HXLINE( 662)					_hx_tmp1 = ::hx::IsNull( j->parent );
            				}
            				else {
HXLINE( 662)					_hx_tmp1 = true;
            				}
HXDLIN( 662)				if (!(_hx_tmp1)) {
HXLINE( 662)					_hx_tmp = ::hx::IsNull( j->parent->offsets );
            				}
            				else {
HXLINE( 662)					_hx_tmp = true;
            				}
HXDLIN( 662)				if (_hx_tmp) {
HXLINE( 662)					continue;
            				}
HXLINE( 663)				 ::h3d::col::Bounds poff = j->parent->offsets;
HXLINE( 666)				 ::h3d::col::Bounds _this = j->offsets;
HXDLIN( 666)				Float dx = (_this->xMax - _this->xMin);
HXDLIN( 666)				Float dy = (_this->yMax - _this->yMin);
HXDLIN( 666)				Float dz = (_this->zMax - _this->zMin);
HXDLIN( 666)				Float sp_x = ((_this->xMin + _this->xMax) * ((Float)0.5));
HXDLIN( 666)				Float sp_y = ((_this->yMin + _this->yMax) * ((Float)0.5));
HXDLIN( 666)				Float sp_z = ((_this->zMin + _this->zMax) * ((Float)0.5));
HXDLIN( 666)				Float sp_r = (::Math_obj::sqrt((((dx * dx) + (dy * dy)) + (dz * dz))) * ((Float)0.5));
HXLINE( 667)				bool _hx_tmp2;
HXDLIN( 667)				bool _hx_tmp3;
HXDLIN( 667)				bool _hx_tmp4;
HXDLIN( 667)				bool _hx_tmp5;
HXDLIN( 667)				bool _hx_tmp6;
HXDLIN( 667)				if ((poff->xMin <= (sp_x - sp_r))) {
HXLINE( 667)					_hx_tmp6 = (poff->yMin <= (sp_y - sp_r));
            				}
            				else {
HXLINE( 667)					_hx_tmp6 = false;
            				}
HXDLIN( 667)				if (_hx_tmp6) {
HXLINE( 667)					_hx_tmp5 = (poff->zMin <= (sp_z - sp_r));
            				}
            				else {
HXLINE( 667)					_hx_tmp5 = false;
            				}
HXDLIN( 667)				if (_hx_tmp5) {
HXLINE( 667)					_hx_tmp4 = (poff->xMax >= (sp_x + sp_r));
            				}
            				else {
HXLINE( 667)					_hx_tmp4 = false;
            				}
HXDLIN( 667)				if (_hx_tmp4) {
HXLINE( 667)					_hx_tmp3 = (poff->yMax >= (sp_y + sp_r));
            				}
            				else {
HXLINE( 667)					_hx_tmp3 = false;
            				}
HXDLIN( 667)				if (_hx_tmp3) {
HXLINE( 667)					_hx_tmp2 = (poff->zMax >= (sp_z + sp_r));
            				}
            				else {
HXLINE( 667)					_hx_tmp2 = false;
            				}
HXDLIN( 667)				if (_hx_tmp2) {
HXLINE( 668)					j->offsets = null();
HXLINE( 669)					optOut = (optOut + 1);
HXLINE( 670)					continue;
            				}
HXLINE( 673)				 ::h3d::col::Bounds b =  ::h3d::col::Bounds_obj::__alloc( HX_CTX );
HXDLIN( 673)				b->xMin = poff->xMin;
HXDLIN( 673)				b->xMax = poff->xMax;
HXDLIN( 673)				b->yMin = poff->yMin;
HXDLIN( 673)				b->yMax = poff->yMax;
HXDLIN( 673)				b->zMin = poff->zMin;
HXDLIN( 673)				b->zMax = poff->zMax;
HXDLIN( 673)				 ::h3d::col::Bounds pext = b;
HXLINE( 674)				{
HXLINE( 674)					Float x = sp_x;
HXDLIN( 674)					Float y = sp_y;
HXDLIN( 674)					Float z = sp_z;
HXDLIN( 674)					Float r = sp_r;
HXDLIN( 674)					if (((x - r) < pext->xMin)) {
HXLINE( 674)						pext->xMin = (x - r);
            					}
HXDLIN( 674)					if (((x + r) > pext->xMax)) {
HXLINE( 674)						pext->xMax = (x + r);
            					}
HXDLIN( 674)					if (((y - r) < pext->yMin)) {
HXLINE( 674)						pext->yMin = (y - r);
            					}
HXDLIN( 674)					if (((y + r) > pext->yMax)) {
HXLINE( 674)						pext->yMax = (y + r);
            					}
HXDLIN( 674)					if (((z - r) < pext->zMin)) {
HXLINE( 674)						pext->zMin = (z - r);
            					}
HXDLIN( 674)					if (((z + r) > pext->zMax)) {
HXLINE( 674)						pext->zMax = (z + r);
            					}
            				}
HXLINE( 678)				Float ratio = ::Math_obj::sqrt(((refVolume * ((Float)1.5)) / (((pext->xMax - pext->xMin) * (pext->yMax - pext->yMin)) * (pext->zMax - pext->zMin))));
HXLINE( 679)				Float k = ((((pext->xMax - pext->xMin) * (pext->yMax - pext->yMin)) * (pext->zMax - pext->zMin)) / (((poff->xMax - poff->xMin) * (poff->yMax - poff->yMin)) * (poff->zMax - poff->zMin)));
HXLINE( 681)				if ((k < ratio)) {
HXLINE( 682)					j->parent->offsets = pext;
HXLINE( 683)					j->offsets = null();
HXLINE( 684)					optOut = (optOut + 1);
HXLINE( 685)					continue;
            				}
            			}
            		}
HXLINE( 693)		{
HXLINE( 693)			int _g3 = 0;
HXDLIN( 693)			::Array< ::Dynamic> _g4 = skin->allJoints;
HXDLIN( 693)			while((_g3 < _g4->length)){
HXLINE( 693)				 ::h3d::anim::Joint j = _g4->__get(_g3).StaticCast<  ::h3d::anim::Joint >();
HXDLIN( 693)				_g3 = (_g3 + 1);
HXLINE( 694)				if (::hx::IsNull( j->offsets )) {
HXLINE( 695)					j->offsetRay = ( (Float)(-1) );
HXLINE( 696)					continue;
            				}
HXLINE( 698)				 ::h3d::col::Bounds b = j->offsets;
HXLINE( 699)				 ::h3d::col::Point pt1;
HXDLIN( 699)				 ::h3d::col::Point pt2;
HXDLIN( 699)				Float off_x = ((b->xMin + b->xMax) * ((Float)0.5));
HXDLIN( 699)				Float off_y = ((b->yMin + b->yMax) * ((Float)0.5));
HXDLIN( 699)				Float off_z = ((b->zMin + b->zMax) * ((Float)0.5));
HXDLIN( 699)				Float r;
HXLINE( 700)				bool _hx_tmp;
HXDLIN( 700)				if (((b->xMax - b->xMin) > (b->yMax - b->yMin))) {
HXLINE( 700)					_hx_tmp = ((b->xMax - b->xMin) > (b->zMax - b->zMin));
            				}
            				else {
HXLINE( 700)					_hx_tmp = false;
            				}
HXDLIN( 700)				if (_hx_tmp) {
HXLINE( 701)					Float a = (b->yMax - b->yMin);
HXDLIN( 701)					Float b1 = (b->zMax - b->zMin);
HXDLIN( 701)					Float r1;
HXDLIN( 701)					if ((a < b1)) {
HXLINE( 701)						r1 = b1;
            					}
            					else {
HXLINE( 701)						r1 = a;
            					}
HXDLIN( 701)					r = (r1 * ((Float)0.5));
HXLINE( 702)					pt1 =  ::h3d::col::Point_obj::__alloc( HX_CTX ,(b->xMin + r),off_y,off_z);
HXLINE( 703)					pt2 =  ::h3d::col::Point_obj::__alloc( HX_CTX ,(b->xMax - r),off_y,off_z);
            				}
            				else {
HXLINE( 704)					if (((b->yMax - b->yMin) > (b->zMax - b->zMin))) {
HXLINE( 705)						Float a = (b->xMax - b->xMin);
HXDLIN( 705)						Float b1 = (b->zMax - b->zMin);
HXDLIN( 705)						Float r1;
HXDLIN( 705)						if ((a < b1)) {
HXLINE( 705)							r1 = b1;
            						}
            						else {
HXLINE( 705)							r1 = a;
            						}
HXDLIN( 705)						r = (r1 * ((Float)0.5));
HXLINE( 706)						pt1 =  ::h3d::col::Point_obj::__alloc( HX_CTX ,off_x,(b->yMin + r),off_z);
HXLINE( 707)						pt2 =  ::h3d::col::Point_obj::__alloc( HX_CTX ,off_x,(b->yMax - r),off_z);
            					}
            					else {
HXLINE( 709)						Float a = (b->xMax - b->xMin);
HXDLIN( 709)						Float b1 = (b->yMax - b->yMin);
HXDLIN( 709)						Float r1;
HXDLIN( 709)						if ((a < b1)) {
HXLINE( 709)							r1 = b1;
            						}
            						else {
HXLINE( 709)							r1 = a;
            						}
HXDLIN( 709)						r = (r1 * ((Float)0.5));
HXLINE( 710)						pt1 =  ::h3d::col::Point_obj::__alloc( HX_CTX ,off_x,off_y,(b->zMin + r));
HXLINE( 711)						pt2 =  ::h3d::col::Point_obj::__alloc( HX_CTX ,off_x,off_y,(b->zMax - r));
            					}
            				}
HXLINE( 713)				{
HXLINE( 713)					b->xMin = pt1->x;
HXDLIN( 713)					b->yMin = pt1->y;
HXDLIN( 713)					b->zMin = pt1->z;
            				}
HXLINE( 714)				{
HXLINE( 714)					b->xMax = pt2->x;
HXDLIN( 714)					b->yMax = pt2->y;
HXDLIN( 714)					b->zMax = pt2->z;
            				}
HXLINE( 715)				j->offsetRay = r;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Library_obj,loadSkin,(void))


::hx::ObjectPtr< Library_obj > Library_obj::__new( ::hxd::res::Resource res, ::hxd::fmt::hmd::Data header) {
	::hx::ObjectPtr< Library_obj > __this = new Library_obj();
	__this->__construct(res,header);
	return __this;
}

::hx::ObjectPtr< Library_obj > Library_obj::__alloc(::hx::Ctx *_hx_ctx, ::hxd::res::Resource res, ::hxd::fmt::hmd::Data header) {
	Library_obj *__this = (Library_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Library_obj), true, "hxd.fmt.hmd.Library"));
	*(void **)__this = Library_obj::_hx_vtable;
	__this->__construct(res,header);
	return __this;
}

Library_obj::Library_obj()
{
}

void Library_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Library);
	HX_MARK_MEMBER_NAME(resource,"resource");
	HX_MARK_MEMBER_NAME(header,"header");
	HX_MARK_MEMBER_NAME(cachedPrimitives,"cachedPrimitives");
	HX_MARK_MEMBER_NAME(cachedAnimations,"cachedAnimations");
	HX_MARK_MEMBER_NAME(cachedSkin,"cachedSkin");
	HX_MARK_END_CLASS();
}

void Library_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(resource,"resource");
	HX_VISIT_MEMBER_NAME(header,"header");
	HX_VISIT_MEMBER_NAME(cachedPrimitives,"cachedPrimitives");
	HX_VISIT_MEMBER_NAME(cachedAnimations,"cachedAnimations");
	HX_VISIT_MEMBER_NAME(cachedSkin,"cachedSkin");
}

::hx::Val Library_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"load") ) { return ::hx::Val( load_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"header") ) { return ::hx::Val( header ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getData") ) { return ::hx::Val( getData_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"resource") ) { return ::hx::Val( resource ); }
		if (HX_FIELD_EQ(inName,"makeSkin") ) { return ::hx::Val( makeSkin_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadSkin") ) { return ::hx::Val( loadSkin_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"cachedSkin") ) { return ::hx::Val( cachedSkin ); }
		if (HX_FIELD_EQ(inName,"getBuffers") ) { return ::hx::Val( getBuffers_dyn() ); }
		if (HX_FIELD_EQ(inName,"makeObject") ) { return ::hx::Val( makeObject_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"makeMaterial") ) { return ::hx::Val( makeMaterial_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"makePrimitive") ) { return ::hx::Val( makePrimitive_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadAnimation") ) { return ::hx::Val( loadAnimation_dyn() ); }
		if (HX_FIELD_EQ(inName,"makeAnimation") ) { return ::hx::Val( makeAnimation_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"cachedPrimitives") ) { return ::hx::Val( cachedPrimitives ); }
		if (HX_FIELD_EQ(inName,"cachedAnimations") ) { return ::hx::Val( cachedAnimations ); }
		if (HX_FIELD_EQ(inName,"getDefaultFormat") ) { return ::hx::Val( getDefaultFormat_dyn() ); }
		if (HX_FIELD_EQ(inName,"getModelProperty") ) { return ::hx::Val( getModelProperty_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"makeLinearAnimation") ) { return ::hx::Val( makeLinearAnimation_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Library_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"header") ) { header=inValue.Cast<  ::hxd::fmt::hmd::Data >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"resource") ) { resource=inValue.Cast<  ::hxd::res::Resource >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"cachedSkin") ) { cachedSkin=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"cachedPrimitives") ) { cachedPrimitives=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cachedAnimations") ) { cachedAnimations=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Library_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("resource",ce,5c,a0,12));
	outFields->push(HX_("header",8d,09,00,fd));
	outFields->push(HX_("cachedPrimitives",6e,dc,69,9e));
	outFields->push(HX_("cachedAnimations",71,07,67,db));
	outFields->push(HX_("cachedSkin",7f,3b,cb,7a));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Library_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::hxd::res::Resource */ ,(int)offsetof(Library_obj,resource),HX_("resource",ce,5c,a0,12)},
	{::hx::fsObject /*  ::hxd::fmt::hmd::Data */ ,(int)offsetof(Library_obj,header),HX_("header",8d,09,00,fd)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Library_obj,cachedPrimitives),HX_("cachedPrimitives",6e,dc,69,9e)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(Library_obj,cachedAnimations),HX_("cachedAnimations",71,07,67,db)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(Library_obj,cachedSkin),HX_("cachedSkin",7f,3b,cb,7a)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Library_obj_sStaticStorageInfo = 0;
#endif

static ::String Library_obj_sMemberFields[] = {
	HX_("resource",ce,5c,a0,12),
	HX_("header",8d,09,00,fd),
	HX_("cachedPrimitives",6e,dc,69,9e),
	HX_("cachedAnimations",71,07,67,db),
	HX_("cachedSkin",7f,3b,cb,7a),
	HX_("getData",e0,05,e6,14),
	HX_("getDefaultFormat",62,0c,28,62),
	HX_("load",26,9a,b7,47),
	HX_("getBuffers",7d,29,f2,00),
	HX_("makePrimitive",d9,80,01,20),
	HX_("makeMaterial",b5,f0,7d,35),
	HX_("makeSkin",8b,0b,f3,42),
	HX_("getModelProperty",a8,22,1c,57),
	HX_("makeObject",4d,53,0f,67),
	HX_("loadAnimation",fe,bf,9a,cd),
	HX_("makeAnimation",36,e7,dd,43),
	HX_("makeLinearAnimation",11,c2,d6,cf),
	HX_("loadSkin",c3,e7,f4,bc),
	::String(null()) };

::hx::Class Library_obj::__mClass;

void Library_obj::__register()
{
	Library_obj _hx_dummy;
	Library_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hxd.fmt.hmd.Library",71,c7,e9,3d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Library_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Library_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Library_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Library_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace hxd
} // end namespace fmt
} // end namespace hmd
